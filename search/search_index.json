{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#ckanext-collection","title":"ckanext-collection","text":"<p>Tools for building interfaces for data collections.</p> <p>This extension simplifies describing series of items, such as datasets from search page, users registered on portal, rows of CSV file, tables in DB, etc. Once you defined the way items are obtained from data source, you'll get generic interface for pagination, search and displaying data in any format: HTML page, CSV document, JSON list, or any other custom format that you can describe.</p> <p>Read the documentation for a full user guide.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install the extension</p> <pre><code>pip install ckanext-collection\n</code></pre> <p>Add <code>collection</code> to the <code>ckan.plugins</code> setting in your CKAN config file</p> <p>Define the collection</p> <pre><code>from ckan import model\nfrom ckanext.collection.utils import *\n\n\n## collection of all resources\nclass MyCollection(Collection):\n    DataFactory = ModelData.with_attributes(model=model.Resource)\n    # `names` controls names of fields exported by serializer\n    # further in this guide\n    ColumnsFactory = cu.Columns.with_attributes(names=[\"name\", \"size\"])\n\n## collection of all packages available via search API\nclass MyCollection(Collection):\n    DataFactory = ApiSearchData.with_attributes(action=\"package_search\")\n    ColumnsFactory = cu.Columns.with_attributes(names=[\"name\", \"title\"])\n\n## collection of all records from CSV file\nclass MyCollection(Collection):\n    DataFactory = CsvData.with_attributes(source=\"/path/to/file.csv\")\n    ColumnsFactory = cu.Columns.with_attributes(names=[\"a\", \"b\"])\n</code></pre> <p>Initialize collection object and work with data:</p> <pre><code># collection with first page of results(1st-10th items)\ncol = MyCollection(\"\", {})\nitems = list(col)\n\n# collection with third page of results(21st-30th items)\ncol = MyCollection(\"\", {\"page\": 3})\nitems = list(col)\n\n\n# alternatively, read all the items into memory at once, without pagination.\n# It may be quite expensive operation depending on number of items\ncol = MyCollection(\"\", {})\nitems = list(col.data)\n\n# or get the slice of data from 2nd till 5th(not includeing 5th,\n# just like in python slices)\nitems = col.data.range(2, 5)\n\n# check total number of items in collection\nprint(col.data.total)\n</code></pre> <p>Serialize data using <code>Serializer</code> service:</p> <pre><code># serialize into JSON string\nserializer = JsonSerializer(col)\n\n# or serialize into CSV string\nserializer = CsvSerializer(col)\n\n# or serialize into list of dictionaries\nserializer = DictListSerializer(col)\n\n\nprint(serializer.serialize())\n</code></pre>"},{"location":"#license","title":"License","text":"<p>AGPL</p>"},{"location":"detailed/","title":"Deep dive","text":""},{"location":"detailed/#content","title":"Content","text":"<ul> <li>Requirements</li> <li>Installation</li> <li>Usage</li> <li>Documentation</li> <li>Overview</li> <li>Collection intialization</li> <li>Services<ul> <li>Common logic</li> <li>Data service</li> <li>Pager service</li> <li>Serializer service</li> <li>Columns service</li> <li>Filters service</li> </ul> </li> <li>Core classes and usage examples<ul> <li>Collection</li> <li>DbCollection</li> <li>Data</li> <li>StaticData</li> <li>BaseSaData</li> <li>StatementSaData</li> <li>UnionSaData</li> <li>ModelData</li> <li>TableData</li> <li>ApiData</li> <li>ApiSearchData</li> <li>ApiListData</li> <li>Pager</li> <li>ClassicPager</li> <li>Columns</li> <li>TableColumns</li> <li>Filters</li> <li>Serializer</li> <li>CsvSerializer</li> <li>JsonlSerializer</li> <li>JsonSerializer</li> <li>HtmlSerializer</li> <li>TableSerializer</li> <li>HtmxTableSerializer</li> </ul> </li> <li>Config settings</li> <li>Integrations</li> <li>ckanext-admin-panel</li> <li>License</li> </ul>"},{"location":"detailed/#requirements","title":"Requirements","text":"<p>Compatibility with core CKAN versions:</p> CKAN version Compatible? 2.9 no 2.10 yes master yes"},{"location":"detailed/#installation","title":"Installation","text":"<p>To install ckanext-collection:</p> <ol> <li> <p>Install the extension:    <pre><code>pip install ckanext-collection\n</code></pre></p> </li> <li> <p>Add <code>collection</code> to the <code>ckan.plugins</code> setting in your CKAN    config file .</p> </li> </ol>"},{"location":"detailed/#usage","title":"Usage","text":"<p>Collections can be registered via <code>ckanext.collection.interfaces.ICollection</code> or via CKAN signals. Registered collection can be initialized anywhere in code using helper and can be used in a number of generic endpoints that render collection as HTML of export it into different formats.</p> <p>Registration via interface:</p> <pre><code>from ckanext.collection.interfaces import CollectionFactory, ICollection\n\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(ICollection, inherit=True)\n\n    def get_collection_factories(self) -&gt; dict[str, CollectionFactory]:\n        return {\n            \"my-collection\": MyCollection,\n        }\n</code></pre> <p><code>get_collection_factories</code> returns a dictionary with collection names(letters, digits, underscores and hyphens are allowed) as keys, and collection factories as values. In most generic case, collection factory is just a collection class. But you can use any function with signature <code>(str, dict[str, Any], **Any) -&gt; Collection</code> as a factory. For example, the following function is a valid collection factory and it can be returned from <code>get_collection_factories</code></p> <pre><code>def my_factory(name: str, params: dict[str, Any], **kwargs: Any):\n    \"\"\"Collection that shows 100 numbers per page\"\"\"\n    params.setdefault(\"rows_per_page\", 100)\n    return MyCollection(name, params, **kwargs)\n</code></pre> <p>If you want to register a collection only if collection plugin is enabled, you can use CKAN signals instead of wrapping import from ckanext-collection into try except block:</p> <pre><code>class MyPlugin(p.SingletonPlugin):\n    p.implements(p.ISignal)\n\n    def get_signal_subscriptions(self) -&gt; types.SignalMapping:\n        return {\n            tk.signals.ckanext.signal(\"collection:register_collections\"): [\n                self.collect_collection_factories,\n            ],\n        }\n\n    def collect_collection_factories(self, sender: None):\n        return {\n            \"my-collection\": MyCollection,\n        }\n</code></pre> <p>Data returned from the signal subscription is exactly the same as from <code>ICollection.get_collection_factories</code>. The only difference, signal subscription accepts <code>sender</code> argument which is always <code>None</code>, due to internal implementation of signals.</p>"},{"location":"detailed/#documentation","title":"Documentation","text":""},{"location":"detailed/#overview","title":"Overview","text":"<p>The goal of this plugin is to supply you with generic classes for processing collections of data. As result, it doesn't do much out of the box and you have to write some code to see a result.</p> <p>Majority of useful classes are available inside <code>ckanext.collection.utils</code> module and all examples bellow require the following line in the beginning of the script: <code>from ckanext.collection.utils import *</code>.</p> <p>Let's start with the basics. <code>ckanext-collection</code> defines a few collections for different puproses. The most basic collection is <code>Collection</code>, but it has no value without customization, so we'll start from <code>StaticCollection</code>:</p> <pre><code>col = StaticCollection(\"name\", {})\n</code></pre> <p>Constructor of any collection has two mandatory arguments: name and parameters. Name is mostly used internally and consists of any combination of letters, digits, hyphens and underscores. Parameters are passed inside the dictionary and they change the content of the collection.</p> <p>In the most basic scenario, collection represents a number of similar items: datasets, users, organizations, dictionaries, numbers, etc. As result, it can be transformed into list or iterated over:</p> <pre><code>list(col)\n\nfor item in col:\n    print(item)\n</code></pre> <p>Our test collection is empty at the moment, so you will not see anything just yet. Usually, <code>StaticCollection</code> contains static data, specified when collection is created. But because we haven't specified any data, collection contains nothing.</p> <p>To fix this problem, we have to configure a part of the collection responsible for data production using its settings. Collection divides its internal logic between a number of configurable services, and service that we need is called data service. To modify it, we can pass a named argument called <code>data_settings</code> to the collection's constructor:</p> <pre><code>col = StaticCollection(\n    \"name\", {},\n    data_settings={\"data\": [1,2,3]}\n)\n</code></pre> <p>Now try again iterating over the collection and now you'll see the result:</p> <pre><code>for item in col:\n    print(item)\n</code></pre> <p>It's not very impressive, but you didn't expect much from static collection, right? There are other collections that are more smart, but we have to learn more concepts of this extension to use them, so for now we'll only take a brief look on them.</p> <p>Note: collections have certain restrictions when it comes to amount of data. By default, you'll see only around 10 records, even if you have more. The same is true for <code>StaticCollection</code> - you can see it if you set <code>data</code> attribute of its data-service to <code>range(1, 100)</code>. We'll learn how to control these restrictions later.</p> <p><code>StaticCollection</code> works with static data. It can be used for tests or as a placeholder for a collection that is not yet implemented. In rare cases it can be used with arbitrary iterable to create a standard interface for data interaction.</p> <p><code>ModelCollection</code> works with SQLAlchemy models. We are going to use two attributes of its data-service: <code>model</code> and <code>is_scalar</code>. The former sets actual model that collection processes, while the latter controls, how we work with every individual record. By default, <code>ModelCollection</code> returns every record as a number of columns, but we'll set <code>is_scalar=True</code> and receive model instance for every record instead:</p> <pre><code>col = ModelCollection(\n    \"\", {},\n    data_settings={\"is_scalar\": True, \"model\": model.User}\n)\n\nfor user in col:\n  assert isinstance(user, model.User)\n  print(f\"{user.name}, {user.email}\")\n</code></pre> <p><code>ApiSearchCollection</code> works with API actions similar to <code>package_search</code>. They have to use <code>rows</code> and <code>start</code> parameters for pagination and their result must contain <code>count</code> and <code>results</code> keys. Its data-service accepts <code>action</code> attribute with the name of API action that produces the data:</p> <pre><code>col = ApiSearchCollection(\n    \"\", {},\n    data_settings={\"action\": \"package_search\"}\n)\n\nfor pkg in col:\n  print(f\"{pkg['id']}: {pkg['title']}\")\n</code></pre> <p><code>ApiListCollection</code> works with API actions similar to <code>package_list</code>. They have to use <code>limit</code> and <code>offset</code> parameters for pagination and their result must be represented by a list.</p> <pre><code>col = ApiListCollection(\n    \"\", {},\n    data_settings={\"action\": \"package_list\"}\n)\n\nfor name in col:\n  print(name)\n</code></pre> <p><code>ApiCollection</code> works with API actions similar to <code>user_list</code>. They have to return all records at once, as list.</p> <pre><code>col = ApiCollection(\n    \"\", {},\n    data_settings={\"action\": \"user_list\"}\n)\n\nfor user in col:\n  print(user[\"name\"])\n</code></pre>"},{"location":"detailed/#collection-intialization","title":"Collection intialization","text":"<p>Collection constructor has two mandatory arguments: name and parameters.</p> <p>Name is used as collection identifier and it's better to keep this value unique accross collections. For example, name is used for computing HTML table <code>id</code> attribute when serializing collection as an HTML table. If you render two collections with the same name, you'll get two identical IDs on the page.</p> <p>Params are usually used by data and pager service for searching, sorting, etc. Collection does not keep all the params. Instead, it stores only items with key prefixed by <code>&lt;name&gt;:</code>. I.e, if collection has name <code>hello</code>, and you pass <code>{\"hello:a\": 1, \"b\": 2, \"world:c\": 3}</code>, collection will remove <code>b</code>(because it has no collection name plus colon prefix) and <code>world:c</code> members(because it uses <code>world</code> instead of <code>hello</code> in prefix). As for <code>hello:a</code>, collection strips <code>&lt;name&gt;:</code> prefix from it. So, in the end, collection stores <code>{\"a\": 1}</code>.  You can check params of the collection using <code>params</code> attribute:</p> <pre><code>col = Collection(\"hello\", {\"hello:a\": 1, \"b\": 2, \"world:c\": 3})\nassert col.params == {\"a\": 1}\n\ncol = Collection(\"world\", {\"hello:a\": 1, \"b\": 2, \"world:c\": 3})\nassert col.params == {\"c\": 3}\n</code></pre> <p>It allows you rendering and processing multiple collections simultaneously on the same page. Imagine that you have collection <code>users</code> and collection <code>packages</code>. You want to see second page of <code>users</code> and fifth of <code>packages</code>. Submit the query string <code>?users:page=2&amp;packages:page=5</code> and initialize collections using the following code:</p> <pre><code>from ckan.logic import parse_params\nfrom ckan.plugins import toolkit as tk\n\nparams = parse_params(tk.request.args)\n\nusers = ModelCollection(\n    \"users\", params,\n    data_settings={\"model\": model.User}\n)\npackages = ModelCollection(\n    \"packages\", params,\n    data_settings={\"model\": model.Package}\n)\n\nassert users.pager.page == 2\nassert packages.pager.page == 5\n</code></pre>"},{"location":"detailed/#services","title":"Services","text":"<p>Collection itself contains just a bare minimum of logic, and all the heavy-lifting is delegated to services. Collection knows how to initialize services and usually the only difference between all your collections, is the way all their services are configured.</p> <p>Collection contains the following services: * <code>data</code>: controls the exact data that can be received from   collection. Contains logic for searching, filters, sorting, etc. * <code>pager</code>: defines restrictions for data iteration. Exactly this service shows   only 10 records when you iterating over static collection * <code>serializer</code>: specifies how collection can be transformed into desired   form. Using correct serializer you'll be able to dump the whole collection as   CSV, JSON, YAML or render it as HTML table. * <code>columns</code>: contains configuration of specific data columns used by other   services. It may define model attributes that are dumped into CSV, names of   the transformation functions that are applied to the certain attribute, names   of the columns that are available for sorting in HTML representation of data. * <code>filters</code>: contains configuration of additional widgets produced during data   serialization. For example, when data is serialized into an HTML table,   filters can define configuration of dropdowns and input fields from the data   search form.</p> <p>Note: You can define more services in custom collections. The list above enumerates all the services that are available in the base collection and in all collections shipped with the current extension. For example, one of built-in collections, <code>DbCollection</code> has additional service called <code>db_connection</code> that can communicate with DB.</p> <p>When a collection is created, it creates an instance of each service using service factories and service settings. Base collection and all collections that extend it already have all details for initializing every service:</p> <pre><code>col = Collection(\"name\", {})\nprint(f\"\"\"Services:\n  {col.data=},\n  {col.pager=},\n  {col.serializer=},\n  {col.columns=},\n  {col.filters=}\"\"\")\n\nassert list(col) == []\n</code></pre> <p>This collection has no data. We can initialize an instance of <code>StaticData</code> and replace the existing data service of the collection with new <code>StaticData</code> instance.</p> <p>Every service has one required argument: collection that owns the service. All other arguments are used as a service settings and must be passed by name. Remember, all the classes used in this manual are available inside <code>ckanext.collection.utils</code>:</p> <pre><code>static_data = StaticData(col, data=[1,2,3])\ncol.replace_service(static_data)\n\nassert list(col) == [1, 2, 3]\n</code></pre> <p>Look at <code>Colletion.replace_service</code>. It accepts only service instance. There is no need to pass the name of the service that must be replaced - collection can understand it without help. And pay attention to the first argument of service constructor. It must be the collection that is going to use the service. Some services may work even if you pass a random value as the first argument, but it's an exceptional situation and one shouldn't rely on it.</p> <p>If existing collection is no longer used and you are going to create a new one, you sometimes want to reuse a service from an existing collection. Just to avoid creating the service and calling <code>Collection.replace_service</code>, which will save you two lines of code. In this case, use <code>&lt;service&gt;_instance</code> parameter of the collection constructor:</p> <pre><code>another_col = Collection(\"another-name\", {}, data_instance=col.data)\nassert list(another_col) == [1, 2, 3]\n</code></pre> <p>If you do such thing, make sure you are not using old collection anymore. You just transfered one of its services to another collection, so there is no guarantees that old collection with detached service will function properly.</p> <p>It's usually better to customize service factory, instead of passing existing customized instance of the service around. You can tell which class to use for making an instance of a service using <code>&lt;service&gt;_factory</code> parameter of the collection contstructor:</p> <pre><code>col = Collection(\"name\", {}, data_factory=StaticData)\nassert list(col) == []\n</code></pre> <p>But in this way we cannot specify the <code>data</code> attribute of the <code>data</code> factory! No worries, there are multiple ways to overcome this problem. First of all, all the settings of the service are available as its attributes. It means that <code>data</code> setting is the same as <code>data</code> attribute of the service. If you can do <code>StaticData(..., data=...)</code>, you can as well do <code>service = StaticData(...); service.data = ...</code>:</p> <pre><code>col = Collection(\"name\", {}, data_factory=StaticData)\ncol.data.data = [1, 2, 3]\nassert list(col) == [1, 2, 3]\n</code></pre> <p>Note: <code>data</code> service caches its data. If you already accessed data property from the <code>StaticData</code>, assigning an new value doesn't have any effect because of the cache. You have to call <code>col.data.refresh_data()</code> after assigning to rebuild the cache.</p> <p>But there is a better way. You can pass <code>&lt;service&gt;_settings</code> dictionary to the collection constructor and it will be passed down into corresponding service factory:</p> <pre><code>col = Collection(\n    \"name\", {},\n    data_factory=StaticData,\n    data_settings={\"data\": [1, 2, 3]}\n)\nassert list(col) == [1, 2, 3]\n</code></pre> <p>It works well for individual scenarios, but when you are creating a lot of collections with the static data, you want to omit some standard parameters. In this case you should define a new class that extends Collection and declares <code>&lt;Service&gt;Factory</code> attribute:</p> <pre><code>class MyCollection(Collection):\n    DataFactory = StaticData\n\ncol = MyCollection(\n    \"name\", {},\n    data_settings={\"data\": [1, 2, 3]}\n)\nassert list(col) == [1, 2, 3]\n</code></pre> <p>You still can pass <code>data_factory</code> into <code>MyCollection</code> constructor to override data service factory. But now, by default, <code>StaticData</code> is used when it's not specified explicitly.</p> <p>Finally, if you want to create a subclass of service, that has a specific value of certain attributes, i.e something like this:</p> <pre><code>class OneTwoThreeData(StaticData):\n    data = [1, 2, 3]\n</code></pre> <p>you can use <code>Service.with_attributes(attr_name=attr_value)</code> factory method. It produce a new service class(factory) with specified attributes bound to a static value. For example, that's how we can define a collection, that always contains <code>[1, 2, 3]</code>:</p> <pre><code>class MyCollection(Collection):\n    DataFactory = StaticData.with_attributes(data=[1, 2, 3])\n\ncol = MyCollection(\"name\", {})\nassert list(col) == [1, 2, 3]\n</code></pre> <p>Now you don't have to specify <code>data_factory</code> or <code>data_settings</code> when creating a collection. It will always use <code>StaticData</code> with <code>data</code> set to <code>[1, 2, 3]</code> . Make sure you mean it, because now you cannot override the data using <code>data_settings</code>.</p>"},{"location":"detailed/#common-logic","title":"Common logic","text":"<p>All services share a few common features. First of all, all services contain a reference to the collection that uses/owns the service. Only one collection can own the service. If you move service from one collection to another, you must never use the old collection, that no longer owns the service. Depending on internal implementation of the service, it may work without changes, but we recommend removing such collections. At any point you can get the collection that owns the service via <code>attached</code> attribute of the service:</p> <pre><code>col = Collection(\"name\", {})\nassert col.data.attached is col\nassert col.pager.attached is col\nassert col.columns.attached is col\n\nanother_col = Collection(\n    \"another-name\", {},\n    data_instance=col.data\n)\nassert col.data.attached is not col\nassert col.data.attached is another_col\nassert col.data is another_col.data\n</code></pre> <p>Second common point of services is settings. Let's use <code>StaticData</code> for tests. It has one configurable attribute(setting) - <code>data</code>. We can specify it directly when creating data service instance: <code>StaticData(..., data=DATA)</code>. Or we can specify it via <code>data_settings</code> when creating a collection: <code>StaticCollection(\"name\", {}, data_settings={\"data\": DATA})</code>. In both cases <code>DATA</code> will be available as a <code>data</code> attribute of the data service. But it doesn't mean that we can pass just any attribute in this way:</p> <pre><code>data = StaticData(col, data=[], not_real=True)\nassert hasattr(data, \"data\")\nassert not hasattr(data, \"not_real\")\n</code></pre> <p>To allow overriding the value of attribute via settings, we have to define this attribute as a configurable attribute. For this we need <code>configurable_attribute</code> function from <code>ckanext.collection.shared</code>:</p> <pre><code>class MyData(StaticData):\n    i_am_real = configurable_attribute(False)\n\ndata = MyData(col, data=[], i_am_real=True)\nassert hasattr(data, \"data\")\nassert hasattr(data, \"i_am_real\")\nassert data.i_am_real is True\n</code></pre> <p><code>configurable_attribute</code> accepts either positional default value of the attribute, or named <code>default_factory</code> function that generated default value every time new instance of the service is created. <code>default_factory</code> must accept a single argument - a new service that is instantiated at the moment:</p> <pre><code>class MyData(StaticData):\n    ref = 42\n    i_am_real = shared.configurable_attribute(default_factory=lambda self: self.ref * 10)\n\ndata = MyData(col, data=[])\nassert data.i_am_real == 420\n</code></pre> <p>Never use another configurable attributes in the <code>default_factory</code> - order in which configurable attributes are initialized is not strictly defined. At the moment of writing this manual, configurable attributes were initialized in alphabetical order, but this implementation detail may change in future without notice.</p> <p>TODO: with_attributes</p>"},{"location":"detailed/#data-service","title":"Data service","text":"<p>This service produces the data for collection. Every data service must:</p> <ul> <li>be Iterable and iterate over all available records by default</li> <li>define <code>total</code> property, that reflects number of available records so that   <code>len(list(data)) == data.total</code></li> <li>define <code>range(start: Any, end: Any)</code> method that returns slice of the data</li> </ul> <p>Base class for data services - <code>Data</code> - already contains a simple version of this logic. You need to define only one method to make you custom implementations: <code>compute_data()</code>. When data if accessed for the first time, <code>compute_data</code> is called. Its result cached and used for iteration in for-loops, slicing via <code>range</code> method and size measurement via <code>total</code> property.</p> <pre><code>class CustomData(Data):\n    def compute_data(self) -&gt; Any:\n        return \"abcdefghijklmnopqrstuvwxyz\"\n\ncol = Collection(\"name\", {}, data_factory=CustomData)\nassert list(col) == [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]\nassert col.data.total == 26\nassert col.data.range(-3, None) == \"xyz\"\n</code></pre> <p>If you need more complex data source, make sure you defined <code>__iter__</code>, <code>total</code>, and <code>range</code>:</p> <pre><code>class CustomData(Data):\n    names = configurable_attribute(default_factory=[\"Anna\", \"Henry\", \"Mary\"])\n\n    @property\n    def total(self):\n        return len(self.names)\n\n    def __iter__(self):\n        yield from sorted(self.names)\n\n    def range(self, start: Any, end: Any):\n        if not isinstance(start, str) or not isinstance(end, str):\n            return []\n\n        for name in self:\n            if name &lt; start:\n                continue\n            if name &gt; end:\n                break\n            yield name\n</code></pre>"},{"location":"detailed/#pager-service","title":"Pager service","text":"<p>Pager service sets the upper and lower bounds on data used by collection. Default pager used by collection relies on numeric <code>start</code>/<code>end</code> values. But it's possible to define custom pager that uses alphabetical or temporal bounds, as long as <code>range</code> method of your custom data service supports these bounds.</p> <p>Standard pager(<code>ClassicPager</code>) has two configurable attributes: <code>page</code>(default: 1) and <code>rows_per_page</code>(default: 10).</p> <pre><code>col = StaticCollection(\"name\", {})\nassert col.pager.page == 1\nassert col.pager.rows_per_page == 10\n</code></pre> <p>Because of these values you see only first 10 records from data when iterating the collection. Let's change pager settings:</p> <pre><code>col = StaticCollection(\n    \"name\", {},\n    data_settings={\"data\": range(1, 100)},\n    pager_settings={\"page\": 3, \"rows_per_page\": 6}\n)\nassert list(col) == [13, 14, 15, 16, 17, 18]\n</code></pre> <p>Pagination details are often passed with search parameters and have huge implact on the required data frame. Because of it, if <code>pager_settings</code> are missing, <code>ClassicPager</code> will look for settings inside collection parameters(second argument of the collection constructor). But in this case, pager will use only items that has <code>&lt;collection name&gt;:</code> prefix:</p> <pre><code>col = StaticCollection(\n    \"xxx\",\n    {\"xxx:page\": 3, \"xxx:rows_per_page\": 6},\n    data_settings={\"data\": range(1, 100)}\n)\nassert list(col) == [13, 14, 15, 16, 17, 18]\n\ncol = StaticCollection(\n    \"xxx\",\n    {\"page\": 3, \"rows_per_page\": 6},\n    data_settings={\"data\": range(1, 100)}\n)\nassert list(col) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>"},{"location":"detailed/#serializer-service","title":"Serializer service","text":"<p>Serializer converts data into textual, binary or any other alternative representation. For example, if you want to compute records produced by the <code>data</code> service of the collection into pandas' DataFrame, you should probably use serializer.</p> <p>Serializers are main users of columns service, because it contains details about specific data columns. And serializers often iterate data service directly(ignoring <code>range</code> method), to serialize all available records.</p> <p>The only required method for serializer is <code>serialize</code>. This method must return an data from <code>data</code> service transformed into format provided by serializer. For example, <code>JsonSerializer</code> returns string with JSON-encoded data.</p> <p>You are not restricted by textual or binary formats. Serializer that transforms data into pandas' DataFrame is completely valid version of the serializer.</p> <pre><code>class NewLineSerializer(Serializer):\n    def serialize(self):\n        result = \"\"\n        for item in self.attached.data:\n            result += str(item) + \"\\n\"\n\n        return result\n\ncol = StaticCollection(\n    \"name\", {},\n    serializer_factory=NewLineSerializer,\n    data_settings={\"data\": [1, 2, 3]}\n)\nassert \"\".join(col.serializer.serialize()) == \"1\\n2\\n3\\n\"\n</code></pre>"},{"location":"detailed/#columns-service","title":"Columns service","text":"<p>This service contains additional information about separate columns of data records. It defines following settings:</p> <ul> <li>names: all available column names. Used by other settings of columns service</li> <li>hidden: columns that should not be shown by serializer. Used by serializer   services</li> <li>visible: columns that must be shown by serializer. Used by serializer   services</li> <li>sortable: columns that support sorting. Used by data services</li> <li>filterable: columns that support filtration/facetting. Used by data services</li> <li>searchable: columns that support search by partial match. Used by data   services</li> <li>labels: human readable labels for columns. Used by serializer services</li> </ul> <p>This service contains information used by other service, so defining additional attributes here is completely normal. For example, some custom serializer, that serializes data into ORC, can expect <code>orc_format</code> attribute in the <code>columns</code> service to be available. So you can add as much additional column related details as required into this service.</p>"},{"location":"detailed/#filters-service","title":"Filters service","text":"<p>This service used only by HTML table serializers at the moment. It has two configurable attributes <code>static_filters</code> and <code>static_actions</code>. <code>static_filters</code> are used for building search form for the data table. <code>static_actions</code> are not used, but you can put into it details about batch or record-level actions and use these details to extend one of standard serializers. For example, ckanext-admin-panel defines allowed actions (remove, restore, hide) for content and creates custom templates that are referring these actions.</p>"},{"location":"detailed/#core-classes-and-usage-examples","title":"Core classes and usage examples","text":"<p>TBA</p>"},{"location":"detailed/#data","title":"Data","text":"<p>TBA</p>"},{"location":"detailed/#staticdata","title":"StaticData","text":"<p>TBA</p>"},{"location":"detailed/#basesadata","title":"BaseSaData","text":"<p>TBA</p>"},{"location":"detailed/#statementsadata","title":"StatementSaData","text":"<p>TBA</p>"},{"location":"detailed/#unionsadata","title":"UnionSaData","text":"<p>TBA</p>"},{"location":"detailed/#modeldata","title":"ModelData","text":"<p>TBA</p>"},{"location":"detailed/#apidata","title":"ApiData","text":"<p>TBA</p>"},{"location":"detailed/#apisearchdata","title":"ApiSearchData","text":"<p>TBA</p>"},{"location":"detailed/#apilistdata","title":"ApiListData","text":"<p>TBA</p>"},{"location":"detailed/#pager","title":"Pager","text":"<p>TBA</p>"},{"location":"detailed/#classicpager","title":"ClassicPager","text":"<p>TBA</p>"},{"location":"detailed/#columns","title":"Columns","text":"<p>TBA</p>"},{"location":"detailed/#filters","title":"Filters","text":"<p>TBA</p>"},{"location":"detailed/#serializer","title":"Serializer","text":"<p>TBA</p>"},{"location":"detailed/#csvserializer","title":"CsvSerializer","text":"<p>TBA</p>"},{"location":"detailed/#jsonlserializer","title":"JsonlSerializer","text":"<p>TBA</p>"},{"location":"detailed/#jsonserializer","title":"JsonSerializer","text":"<p>TBA</p>"},{"location":"detailed/#htmlserializer","title":"HtmlSerializer","text":"<p>TBA</p>"},{"location":"detailed/#tableserializer","title":"TableSerializer","text":"<p>TBA</p>"},{"location":"detailed/#htmxtableserializer","title":"HtmxTableSerializer","text":"<p>TBA</p>"},{"location":"detailed/#config-settings","title":"Config settings","text":"<pre><code># Names of registered collections that are viewable by any visitor, including\n# anonymous.\n# (optional, default: )\nckanext.collection.auth.anonymous_collections =\n\n# Names of registered collections that are viewable by any authenticated\n# user.\n# (optional, default: )\nckanext.collection.auth.authenticated_collections =\n\n# Add HTMX asset to pages. Enable this option if you are using CKAN v2.10\n# (optional, default: false)\nckanext.collection.include_htmx_asset = false\n\n# Initialize CKAN JS modules every time HTMX fetches HTML from the server.\n# (optional, default: false)\nckanext.collection.htmx_init_modules = false\n\n# Import path for serializer used by CSV export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:CsvSerializer)\nckanext.collection.export.csv.serializer = ckanext.collection.utils.serialize:CsvSerializer\n\n# Import path for serializer used by JSON export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:JsonSerializer)\nckanext.collection.export.json.serializer = ckanext.collection.utils.serialize:JsonSerializer\n\n# Import path for serializer used by JSONl export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:JsonlSerializer)\nckanext.collection.export.jsonl.serializer = ckanext.collection.utils.serialize:JsonlSerializer\n\n# Import path for serializer used by `format`-export endpoint.\n# (optional, default: )\nckanext.collection.export.&lt;format&gt;.serializer =\n</code></pre>"},{"location":"detailed/#integrations","title":"Integrations","text":""},{"location":"detailed/#ckanext-admin-panel","title":"ckanext-admin-panel","text":"<p>To enable configuration form of ckanext-collection in the admin panel, enable the following arbitrary schema</p> <pre><code>scheming.arbitrary_schemas =\n    ckanext.collection:ap_config.yaml\n</code></pre>"},{"location":"detailed/#license","title":"License","text":"<p>AGPL</p>"}]}