{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#ckanext-collection","title":"ckanext-collection","text":"<p>Tools for building interfaces for data collections using declarative style.</p> <p>This extension simplifies describing series of items, such as datasets from search page, users registered on portal, rows of CSV file, tables in DB, etc. Once you defined the way of fetching items from data source, you'll get generic interface for pagination, search and displaying data in any format: HTML page, CSV document, JSON list, or any other custom format that you can describe.</p> <p>Read the documentation for a full user guide.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install the extension</p> <pre><code>pip install ckanext-collection\n</code></pre> <p>Add <code>collection</code> to the <code>ckan.plugins</code> setting in your CKAN config file</p> <p>Define the collection</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data, columns, serialize\n\n\n## collection of all resources from DB\nclass MyCollection(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(model=model.Resource)\n    # `names` controls names of fields exported by serializer\n    # further in this guide\n    ColumnsFactory = columns.Columns.with_attributes(names=[\"name\", \"size\"])\n\n## collection of all packages available via search API\nclass MyCollection(collection.Collection):\n    DataFactory = data.ApiSearchData.with_attributes(action=\"package_search\")\n    ColumnsFactory = columns.Columns.with_attributes(names=[\"name\", \"title\"])\n\n## collection of all records from CSV file\nclass MyCollection(collection.Collection):\n    DataFactory = data.CsvFileData.with_attributes(source=\"/path/to/file.csv\")\n    ColumnsFactory = columns.Columns.with_attributes(names=[\"a\", \"b\"])\n</code></pre> <p>Initialize collection object and work with data:</p> <pre><code># collection with first page of results(1st-10th items)\ncol = MyCollection()\nitems = list(col)\n\n# collection with third page of results(21st-30th items)\ncol = MyCollection(\"\", {\"page\": 3})\nitems = list(col)\n\n\n# alternatively, read all the items into memory at once, without pagination.\n# It may be quite expensive operation depending on number of items\ncol = MyCollection()\nitems = list(col.data)\n\n# or get the slice of data from 8th till 12th\nitems = list(col.data[8:12])\n\n# check total number of items in collection\nprint(col.data.total)\n</code></pre> <p>Serialize data using <code>Serializer</code> service:</p> <pre><code># JSON string\nserializer = serialize.JsonSerializer(col)\n\n# or CSV string\nserializer = serialize.CsvSerializer(col)\n\n# or python list of dictionaries\nserializer = serialize.DictListSerializer(col)\n\n\nprint(serializer.serialize())\n</code></pre>"},{"location":"#license","title":"License","text":"<p>AGPL</p>"},{"location":"configuration/","title":"Configuration","text":"<pre><code># Names of registered collections that are viewable by any visitor, including\n# anonymous.\n# (optional, default: )\nckanext.collection.auth.anonymous_collections =\n\n# Names of registered collections that are viewable by any authenticated\n# user.\n# (optional, default: )\nckanext.collection.auth.authenticated_collections =\n\n# Add HTMX asset to pages. Enable this option if you are using CKAN v2.10\n# (optional, default: false)\nckanext.collection.include_htmx_asset = false\n\n# Initialize CKAN JS modules every time HTMX fetches HTML from the server.\n# (optional, default: false)\nckanext.collection.htmx_init_modules = false\n\n# Import path for serializer used by CSV export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:CsvSerializer)\nckanext.collection.export.csv.serializer = ckanext.collection.utils.serialize:CsvSerializer\n\n# Import path for serializer used by JSON export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:JsonSerializer)\nckanext.collection.export.json.serializer = ckanext.collection.utils.serialize:JsonSerializer\n\n# Import path for serializer used by JSONl export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:JsonlSerializer)\nckanext.collection.export.jsonl.serializer = ckanext.collection.utils.serialize:JsonlSerializer\n\n# Import path for serializer used by `format`-export endpoint.\n# (optional, default: )\nckanext.collection.export.&lt;format&gt;.serializer =\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Compatibility with core CKAN versions:</p> CKAN version Compatible? 2.9 no 2.10 yes 2.11 yes master yes <p>Install the extension: <pre><code>pip install ckanext-collection\n</code></pre></p> <p>Add <code>collection</code> to the <code>ckan.plugins</code> setting in your CKAN config file .</p>"},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/#ckanext-admin-panel","title":"ckanext-admin-panel","text":"<p>To enable configuration form of ckanext-collection in the admin panel, enable the following arbitrary schema</p> <pre><code>scheming.arbitrary_schemas =\n    ckanext.collection:ap_config.yaml\n</code></pre>"},{"location":"interfaces/","title":"Interfaces","text":""},{"location":"interfaces/#icollection","title":"ICollection","text":"<p>Extend functionality of ckanext-collections.</p> Example <pre><code>import ckan.plugins as p\nfrom ckanext.collection import shared\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(shared.ICollection, inherit=True)\n\n    def get_collection_factories(self) -&gt; dict[str, CollectionFactory]:\n        return {...}\n</code></pre>"},{"location":"interfaces/#collection.interfaces.ICollection.get_collection_factories","title":"<code>get_collection_factories()</code>","text":"<p>Register named collection factories.</p> Example <pre><code>def get_collection_factories(self) -&gt; dict[str, CollectionFactory]:\n    return {\n        \"packages\": PackageCollection,\n    }\n</code></pre> RETURNS DESCRIPTION <code>dict[str, CollectionFactory]</code> <p>mapping of global collection name to collection factory</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#register-collection","title":"Register collection","text":"<p>Collection can be initialized anywhere in code</p> <p>Example</p> <pre><code>from my.module import MyCollection\n\ncol = MyCollection()\n</code></pre> <p>But it's recommended to register collections globally.</p> <p>Collections are registered via ICollection interface or via CKAN signals. Registered collection can be initialized anywhere in code using helper. It can also be used in a number of generic endpoints that render collection as HTML or export it into different formats.</p> Register via interfaceRegister via signal <pre><code>import ckan.plugins as p\nfrom ckanext.collection import shared\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(shared.ICollection, inherit=True)\n\n    def get_collection_factories(\n        self,\n    ) -&gt; dict[str, shared.types.CollectionFactory]:\n        return {\n            \"my-collection\": MyCollection,\n        }\n</code></pre> <pre><code>import ckan.plugins as p\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(p.ISignal)\n\n    def get_signal_subscriptions(self) -&gt; types.SignalMapping:\n        return {\n            tk.signals.ckanext.signal(\"collection:register_collections\"): [\n                get_collection_factories,\n            ],\n        }\n\ndef get_collection_factories(sender: None): # (1)!\n    return {\n        \"my-collection\": MyCollection,\n    }\n</code></pre> <ol> <li>Signal listerners must receive at least one argument containing the sender    of the signal. Signal that register collections always sets <code>None</code> as a    sender.</li> </ol> <p><code>get_collection_factories</code> returns a dictionary with collection names(letters, digits, underscores and hyphens are allowed) as keys, and collection factories as values. In most generic case, collection factory is just a collection's class itself. But you can use any function with signature <code>(str, dict[str, Any], **Any) -&gt; Collection</code> as a factory.</p> <p>Example</p> <p>The following function is a valid collection factory and it can be returned from <code>get_collection_factories</code></p> <pre><code>def my_factory(name: str, params: dict[str, Any], **kwargs: Any):\n    \"\"\"Collection that shows 100 numbers per page\"\"\"\n    params.setdefault(\"rows_per_page\", 100)\n    return MyCollection(name, params, **kwargs)\n</code></pre>"},{"location":"usage/#initialize-collection","title":"Initialize collection","text":"<p>Collection class defines the data source of collection and different aspects of its behavior. But collection class itself does not contain any data and collection instance must be created to work with data.</p> <p>Any collection can be initialized directly, using collection class. And every registered collection can be initialized via <code>get_collection</code> function. Arguments are the same in both cases. Collection requires the name, parameters and accepts arbitrary number of keyword-only arguments, that are passed to underlying services.</p> Initialize registered collectionInitialize collection using class <pre><code>col = get_collection(\n    \"my-collection\",\n    {},\n    pager_settings={\"rows_per_page\": 100}\n)\n</code></pre> <p>Tip</p> <p>Second argument of <code>get_collection</code> expects parameters prefixed by collection name. In example above, to choose the second page, you need to pass <code>{\"my-collection:page\": 2}</code> as parameters.</p> <p>If you are using unprefixed parameters, like <code>{\"page\": 2}</code> and don't want to adapt them to expected form, pass <code>True</code> as the third argument to <code>get_collection</code>, and every key inside parameters will get required prefix automatically.</p> <pre><code>col = get_collection(\n    \"my-collection\",\n    {\"page\": 2},\n    True,\n    pager_settings={\"rows_per_page\": 100}\n)\n</code></pre> <pre><code>col = MyCollection(\n    \"\",\n    {},\n    pager_settings={\"rows_per_page\": 100},\n)\n</code></pre>"},{"location":"usage/#use-collection-data","title":"Use collection data","text":"<p>Tip</p> <p>If you want to try examples below, but you haven't defined any collection yet, you can use the following definition for collection of numbers from 1 to 25:</p> <pre><code>from ckanext.collection.shared import collection, data\nclass MyCollection(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=[\n        {\"number\": num, \"index\": idx}\n        for idx, num in enumerate(range(1,26))\n    ])\n</code></pre> <p>Intended way to access the data is iteration over collection instance. In this way, you access only specific chunk of data, limited by collection's pager.</p> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[{'number': 1, 'index': 0},\n {'number': 2, 'index': 1},\n {'number': 3, 'index': 2},\n {'number': 4, 'index': 3},\n {'number': 5, 'index': 4},\n {'number': 6, 'index': 5},\n {'number': 7, 'index': 6},\n {'number': 8, 'index': 7},\n {'number': 9, 'index': 8},\n {'number': 10, 'index': 9}]\n</code></pre> <p>Different page can be accessed by passing <code>page</code> inside params to collection's constructor</p> <pre><code>&gt;&gt;&gt; col = MyCollection(\"\", {\"page\": 3}) # (1)!\n&gt;&gt;&gt; list(col)\n[{'number': 21, 'index': 20},\n {'number': 22, 'index': 21},\n {'number': 23, 'index': 22},\n {'number': 24, 'index': 23},\n {'number': 25, 'index': 24}]\n</code></pre> <ol> <li>More idiomatic form of this initialization is <code>MyCollection(pager_settings={\"page\": 3}))</code>. But this form is longer an    required deeper knowledge of collections.</li> </ol> <p>If you need to iterate over all collection items, without pagination, you can use <code>data</code> attribute of the collection.</p> <p>Warning</p> <p>Using data directly can result in enormous memory consumption. Avoid transforming data into list(<code>list(col.data)</code>) or processing it as single object in any other way. Instead, iterate over collection items using loops or similar tools.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; sum = 0\n&gt;&gt;&gt; for item in col.data:\n&gt;&gt;&gt;     sum += item[\"number\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(sum)\n325\n</code></pre>"},{"location":"usage/#serialize-collection","title":"Serialize collection","text":"<p>The ultimate goal of every collection is serialization. It may be serialization as HTML to show collection on one of application web-pages. Or serialization as JSON to send collection to the external API. Or serialization as CSV to allow user downloading the collection. Or even serialization as pandas' DataFrame to process data from the collection using more advanced tools.</p> <p><code>serializer</code> service of collection is responsible for serialization. If required format of collections output is known in advance, <code>SerializerFactory</code> can be defined on collection level.</p> <p>If the format of serialization can vary, <code>serializer</code> can be initialized separately.</p> Using SerializerFactoryCreating serializers on demand <pre><code>from ckanext.collection.shared import collection, serialize, data\n\nclass MyCollection(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=[\n        {\"number\": num, \"index\": idx}\n        for idx, num in enumerate(range(1,26))\n    ])\n    SerializerFactory = serialize.CsvSerializer\n\ncol = MyCollection()\nprint(col.serializer.serialize())\n</code></pre> <pre><code>from ckanext.collection.shared import collection, serialize, data\n\nclass MyCollection(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=[\n        {\"number\": num, \"index\": idx}\n        for idx, num in enumerate(range(1,26))\n    ])\n\n\ncol = MyCollection()\n\njson = serialize.JsonSerializer(col)\nprint(json.serialize())\n\ncsv = serialize.CsvSerializer(col)\nprint(csv.serialize())\n</code></pre> <p>Warning</p> <p>Keep in mind, as any other collection's service, serializer attaches itself to collection when initialized and replaces the previous serializer.</p> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; isinstance(col.serializer, serialize.Serializer)\nTrue\n&gt;&gt;&gt; serialize.JsonSerializer(col)\n&gt;&gt;&gt; isinstance(col.serializer, serialize.JsonSerializer)\nTrue\n&gt;&gt;&gt; serialize.CsvSerializer(col)\n&gt;&gt;&gt; isinstance(col.serializer, serialize.CsvSerializer)\nTrue\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>All services provided by the extension are defined using public interfaces. If you don't understand the logic behind a certain service or want to modify its behavior, you can extend existing service or create a new service.</p> <p>Don't try to squeeze project requirements into existing utilities. Instead, define the optimized services that do the work in the most efficient way. Class creation is the base principle of ckanext-collection philosophy, so create classes, and create a lot of them.</p> <p>In this section you'll find examples of collections that were created in real project, and examples that exist only for demonstration. You'll notice that some examples do the same things, but in a different way. For example, packages or users will be listed using <code>data.ModelData</code> in one example, while another example will use <code>data.ApiSearchData</code>.</p> <p>There are no ideal generic solutions, and often different approaches will be interchangeable. Check the example, read the explanation, and choose the flow that is the most efficient and the most readable for you. You can always build a multiple versions of the same collection, create a benchmark for it and swap implementation as project evolves. Collection exposes the data, and how this data is produced is an implementation detail of the collection that is hiddent from other parts of the application. It means, you'll be able to change implementation without breaking any code that uses the collection as long as you keep the output unchanged.</p>"},{"location":"examples/access/","title":"Accessing data","text":"<p>This page contains examples of building collections using standard utilities and reading data from such collections.</p>"},{"location":"examples/access/#get-records-from-the-collection","title":"Get records from the collection","text":"<p>Collection definition:</p> <p>This example uses collection of numbers from 1 to 100</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data, pager\n\nclass Example(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=range(1, 100))\n</code></pre> <p>Collection itself is iterable, so you can access records using for-loop:</p> <pre><code>col = Example()\n\nfor pkg in col:\n    assert isinstance(pkg, int)\n</code></pre> <p>Or you can convert collection into a list:</p> <pre><code>items = list(col)\n</code></pre> <p>When you iterate over collection, only current page of records is yielded. The current page is controlled by pager service. Our example does not configures pager, so we are using default values. Default pager shows the first page, that contains 10 items from the data source.</p> <pre><code>&gt;&gt;&gt; len(items)\n10\n</code></pre> <p>To change the page you can initialize a new instance of the collection and modify pager settings</p> <pre><code>&gt;&gt;&gt; col = Example(pager_settings={\"page\": 3})\n&gt;&gt;&gt; list(col)\n[21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n</code></pre> <p>or you can replace pager service of the collection. To achieve it, initialize a new pager instance, pass collection to its constructor as a first positional argument, and specify pager settings as named arguments. You don't need to save a new pager instance inside the collection properties. You don't need to store pager instance inside any variable at all - when initialized, pager(and any other service) is injected into collection automatically.</p> <p>Collections use <code>pager.ClassicPager</code> by default, and that's what we'll use here</p> <pre><code>&gt;&gt;&gt; pager.ClassicPager(col, page=2)\n&gt;&gt;&gt; list(col)\n[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n</code></pre> <p>If you want to modify size of the page, change value of <code>row_per_page</code> option of the pager. In the following snippet we don't specify <code>page</code>, so it's set to <code>1</code></p> <pre><code>&gt;&gt;&gt; pager.ClassicPager(col, rows_per_page=2)\n&gt;&gt;&gt; list(col)\n[1, 2]\n</code></pre> <p>Instead of <code>pager.ClassicPager</code>, which relies on page number and page size, you can use <code>pager.OffsetPager</code>, which is controlled by limit and offset. Results are the same, only concept is different.</p> <pre><code>&gt;&gt;&gt; pager.OffsetPager(col, offset=14, limit=3)\n&gt;&gt;&gt; list(col)\n[15, 16, 17]\n</code></pre> <p>If it's not enough, you can access data service of the collection directly as <code>col.data</code>. Data service exposes two ways of accessing the records:</p> <ul> <li>data service itself is an iterable, that yields all available records</li> <li>data service has <code>range(start, end)</code> method that returns slice of all   available items.</li> </ul> <p>If you want to process all records in a loop, or transform them into a list, data service is exactly what you need</p> <pre><code>for item in col.data:\n    ...\n\nitems = list(col.data)\n</code></pre> <p>Data service ignores the pager. No matter what page and page size are configured, data service always returns all records when you transform it into a list. Big data sources can consume a lot of memory in this case, so avoid this transformation unless you are sure, your data sample is relatively small.</p> <p>If you want to receive a slice of data source(and don't want to use <code>pager.OffsetPager</code> which does exactly this thing), you can call <code>col.data.range(start, end)</code>. To get 5 items starting from 10th:</p> <pre><code>&gt;&gt;&gt; list(col.data.range(10, 15))\n[11, 12, 13, 14, 15]\n</code></pre> <p><code>range</code> method of the data service is called by collection when it's used as iterable. Collection gets position of the first and last elements from the pager service and passes these parameters to <code>data.range</code>.</p> <p>Implementation of <code>range</code> is provided by the data service. Some services accepts only positive integers as start and end point. Other services may accept negative offsets, float numbers or even dates. We are using <code>StaticData</code> in this example, which transform <code>range</code> calls into slicing of the interal data. I.e, as we are using squence of numbers as data, when <code>range(x, y)</code> is called, internally it's transformed into <code>sequence[x:y]</code>.</p> <p>It means, we can use negative indexes and <code>None</code> with the example collection</p> <pre><code>&gt;&gt;&gt; list(col.data.range(-5, None))\n[95, 96, 97, 98, 99]\n</code></pre> <p>But other data services may not support this type of invocation. It's always a good idea to check specification of the service, before using it.</p>"},{"location":"examples/access/#get-data-from-db-using-sqlalchemy-model","title":"Get data from DB using SQLAlchemy model","text":"<p>Collection definition:</p> <p>This example uses collection of all packages from the DB</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Example(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(model=model.Package)\n</code></pre> <p>When you want fetch data from DB using a single model(something similar to <code>model.Session.query(MODEL)</code>), using <code>data.ModelData</code> is often the simplest option.</p> <p>This service has one mandatory option - <code>model</code>. <code>data.ModelData</code> pulls all records of the specified model from the DB and, by default, returns tuple-like representation of each record.</p> <pre><code>&gt;&gt;&gt; col = Example()\n&gt;&gt;&gt; list(col)[0]\n('id-123', 'name', 'title')\n</code></pre> <p>If you prefer working with model instances(<code>model.Package</code> in our example), enable <code>is_scalar</code> option of the <code>data.ModelData</code> service.</p> <pre><code>&gt;&gt;&gt; col = Example(data_settings={\"is_scalar\": True})\n&gt;&gt;&gt; list(col)[0]\n&lt;Package id=123 name=hehe&gt;\n</code></pre> <p>To filter records, specify <code>static_filters</code> option of the collection. It accepts a collection of conditions that can be used with <code>Query.filter</code>/<code>Select.where</code> methods of SQLAlchemy.</p> <p>All datasets with <code>type=dataset</code> that were crated during last 30 days are described by this collection:</p> <pre><code>from datetime import date, timedelta\n\nfilter_type = model.Package.type == \"dataset\"\nfilter_date = model.Package.metadata_created &gt; date.today() - timedelta(days=30)\n\ncol = Example(\n    data_settings={\n        \"is_scalar\": True,\n        \"static_filters\": [filter_type, filter_date],\n    },\n)\n\nfor item in col:\n    assert item.type == \"dataset\"\n    assert date.today() - item.metadata_created &lt; timedelta(days=30)\n</code></pre>"},{"location":"examples/access/#get-data-from-api-using-package_search-like-action","title":"Get data from API using package_search-like action","text":"<p>Collection definition:</p> <p>This example uses collection of all packages from search API</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Example(collection.Collection):\n    DataFactory = data.ApiSearchData.with_attributes(action=\"package_search\")\n</code></pre> <p>Any action that accepts <code>start</code> and <code>rows</code> parameters and returns result as dictionary with <code>count</code> and <code>results</code> items, can be used with <code>data.ApiSearchData</code>.</p> <p>This service automatically moves through results when you iterate over data. And you can loop through data service and process all the items:</p> <pre><code>col = Example()\n\nfor item in col.data:\n    ...\n</code></pre> <p>If you are working with <code>package_search</code> action directly, you have to write an additional loop that moves offset further and fetches new portion of datasets:</p> <pre><code>start = 0\nsearch = tk.get_action(\"package_search\")\n\nwhile True:\n    resp = search({}, {\"start\": start})[\"results\"]\n\n    if not results:\n        break\n\n    for item in results:\n        ...\n\n    start += len(results)\n</code></pre> <p>And with <code>data.ApiSearchData</code> this happens behind the scene and you just access all the items using iteration over data service.</p> <p>To set the <code>user</code> for the context, or enable <code>ignore_auth</code> flag, pass corresponding options to the data service:</p> <pre><code>col = Example(data_settings={\n    \"user\": \"custom-user\",\n    \"ignore_auth\": True,\n})\n</code></pre> <p>And if you want to override search parameters or set the number of items processed at once, use <code>payload</code> option of <code>data.ApiSearchData</code>.</p> <pre><code>col = Example(data_settings={\n    \"payload\": {\n        \"q\": \"test\",\n        \"fq\": \"field:value\",\n        \"rows\": 100,\n    },\n})\n</code></pre>"},{"location":"examples/access/#get-data-from-db-using-arbitrary-select-statement","title":"Get data from DB using arbitrary select statement","text":"<p>Collection definition:</p> <p>This example uses collection of all packages from search API</p> <pre><code>import sqlalchemy as sa\n\nfrom ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Example(collection.Collection):\n    DataFactory = data.StatementSaData\n</code></pre> <p><code>data.StatementSaData</code> is a low-level version of <code>data.ModelData</code>. Instead of working with SQLAlchemy model, it accepts any SQL statement(<code>sqlalchemy.select</code>) and returns all records from it.</p> <p>Select statement is controlled by <code>statement</code> option of the service.</p> <pre><code>&gt;&gt;&gt; col = Example(data_settings={\n&gt;&gt;&gt;     \"statement\": sa.select(model.User.name, model.User.sysadmin).where(\n&gt;&gt;&gt;         model.User.email.endswith(\"gmail.com\"),\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt; })\n&gt;&gt;&gt; list(col)\n[('first-user', False), ('second-user', True)]\n</code></pre> <p>Records returned as tuple-like object by default. If you select only one column, you still have to work with tuple-like object that contains a single item. To make your life easier, consider enabling <code>is_scalar</code> flag, to return only first column from every row of the data source.</p> <pre><code>&gt;&gt;&gt; col = Example(data_settings={\n&gt;&gt;&gt;     \"statement\": sa.select(model.User.name, model.User.sysadmin).where(\n&gt;&gt;&gt;         model.User.email.endswith(\"gmail.com\"),\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     \"is_scalar\": True\n&gt;&gt;&gt; })\n&gt;&gt;&gt; list(col)\n['first-user', 'second-user']\n</code></pre> <p>Select statement has no restrictions regarding its size or complexity. If required, use joins, group-by/having, subqueries, CTE, etc.</p> <p>For example, a bit more complex collection that shows users and resources inside packages created by them.</p> <pre><code>col = Example(data_settings={\n    \"statement\": sa.select(\n        model.User.name,\n        sa.func.count(model.Resource.id).label(\"res_number\"),\n        sa.func.array_agg(model.Package.name.distinct()).label(\"packages\"),\n        sa.func.array_agg(model.Resource.id).label(\"resources\"),\n    ).join(\n        model.Package, model.Package.creator_user_id == model.User.id,\n    ).join(\n        model.Resource, model.Package.id == model.Resource.package_id\n    ).group_by(model.User.id)\n})\n</code></pre> <pre><code>&gt;&gt;&gt; list(col)\n[('default', 2, ['dataset1'], ['123', '456']),\n ('another-user', 1, ['dataset2'], ['888-888'])]\n</code></pre>"},{"location":"structure/","title":"Structure of the collection","text":""},{"location":"structure/#introduction","title":"Introduction","text":"<p>Collections are designed to describe the data. Most common logic often can be defined declaratively and all imperative commands are ether hidden deep inside different parts of collection or injected as tiny lambda-functions.</p> <p>But describing the data is not simple, especially if data needs to be interactive. As result, collections have complex internal structure. Good news, you don't need to know everything in order to use the collections. As long as you need something simple, you can use the minimum of knowledge.</p> <p>Look how collection with all the users from DB can be created:</p> Using anonymous classes and verbose initializationUsing dedicated class and simple initialization <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection\n\nusers = collection.ModelCollection(data_settings={\"model\": model.User})\n</code></pre> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Users(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(model=model.User)\n\nusers = Users()\n</code></pre> <p>For most standard use-cases, ckanext-collection already contains a number of classes that do the heavy lifting. And in future, as more popular scenarios discovered, the number of classes will grow.</p> <p>Still, custom requirements are often appear in the project. Because of it, understanding how collection works and how it can be customized is the key point in building the perfect collection.</p>"},{"location":"structure/#collection","title":"Collection","text":"<p>Collection itself contains just a bare minimum of logic, and real magic happens inside its services. Collection knows how to initialize services and usually the only difference between all collections, is the way their services are configured.</p>"},{"location":"structure/#services","title":"Services","text":""},{"location":"structure/#data","title":"data","text":"<p>controls the exact data that can be received from collection. Contains logic for searching, filters, sorting, etc.</p>"},{"location":"structure/#pager","title":"pager","text":"<p>defines restrictions for data iteration. Exactly this service limits results to 10 records when you iterating over collection.</p>"},{"location":"structure/#serializer","title":"serializer","text":"<p>specifies how collection can be transformed into specific format. Using correct serializer you'll be able to dump the whole collection as CSV, JSON, YAML or render it as HTML table.</p>"},{"location":"structure/#columns","title":"columns","text":"<p>contains configuration of specific data columns used by other services. It may define model attributes that are dumped into CSV, names of the transformation functions that are applied to the certain attribute, names of the columns that are available for sorting in HTML representation of data.</p> <p>Mainly used by serializer(controls visibility of data fields) and data(controls ability to search, filter and sort by field) services.</p>"},{"location":"structure/#filters","title":"filters","text":"<p>contains configuration of additional widgets produced during data serialization. For example, when data is serialized into an HTML table, filters can define configuration of dropdowns and input fields from the data search form.</p> <p>Tip</p> <p>You can define more services in custom collections. The list above only enumerates the services available in the base collection.</p> <p>For example, one of built-in collections, <code>DbCollection</code> has additional service called <code>db_connection</code> that can communicate with DB.</p>"},{"location":"structure/collection/","title":"Collection","text":""},{"location":"structure/collection/#overview","title":"Overview","text":"<p>Collection works as a proxy between user and collection's services. It hides internal complexity and simplifies access to data.</p> <p>The very base collection contains no data. It can be initialized using <code>Collection</code> constructor.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; list(col)\n[]\n</code></pre> <p>Constructor of collection accepts two positional arguments:</p> <ul> <li><code>name</code>: string containing letters, numbers, underscores and hyphens</li> <li><code>params</code>: dictionary that can be used by services. There are no rules that   define, how exactly params are used and whether or not they are used at   all. Everything depends on services. For example, pager usually checks   <code>page</code> and <code>rows_per_page</code> inside <code>params</code>. Data service often uses fields   from <code>params</code> to filter data.</li> </ul> <p>Note</p> <p><code>params</code> depend on collection name. If the name is empty, params are used without changes. If name is not empty, params are filtered and transformed. First, any member of params that is not prefixed with collection name and colon is removed. Then, the prefix is removed.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\"\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}) # (1)!\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}\n&gt;&gt;&gt; col = collection.Collection(\"xxx\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}) # (2)!\n&gt;&gt;&gt; col.params\n{\"b\": 2}\n&gt;&gt;&gt; col = collection.Collection(\"yyy\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}) # (3)!\n&gt;&gt;&gt; col.params\n{\"c\": 3}\n</code></pre> <ol> <li>All parameter are kept because collection has no name.</li> <li>Only <code>xxx:b</code> is kept and its name transformed to just <code>b</code>, because    collection has name <code>xxx</code>.</li> <li>Only <code>yyy:c</code> is kept and its name transformed to just <code>c</code>, because    collection has name <code>yyy</code>.</li> </ol> Why <code>params</code> are transformed? <p>As long as collection is initialized manually and don't have a name, you don't need to think about <code>params</code> transformation.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\"\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3})\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}\n</code></pre> <p>Transformation becomes important, whn you initialize registered named collection via <code>get_collection</code></p> <pre><code>&gt;&gt;&gt; col = get_collection(\n&gt;&gt;&gt;    \"my-collection\",\n&gt;&gt;&gt;    {\"a\": 1, \"my-collection:b\": 2},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.params\n{\"b\": 2}\n</code></pre> <p>This design decision was made to simplify rendering conllections on webpages.</p> <p>Imagine the page that renders <code>users</code> and <code>packages</code> collection. These collections are rendered as tables with pagination and view code looks like this:</p> <pre><code>import ckan.plugins.toolkit as tk\nfrom ckan.logic import parse_params\n\n@route(...)\ndef users_and_packages():\n    params = parse_params(tk.request.args)\n\n    users = get_collection(\"users\", params)\n    packages = get_collection(\"packages\", params)\n\n    return tk.render(template, {\n        \"users\": users,\n        \"packages\": packages,\n    })\n</code></pre> <p>Because <code>params</code> uses collection name as prefix, it's possible to paginate collections separately. Query string <code>?users:page=2&amp;packages:page=8</code> parsed into <code>params</code> dictionary on the first line of view. This dictionary contains both page values with prefixes. When <code>users</code> and <code>packages</code> collections initialized, they pick only relevant values from <code>params</code>, so <code>users</code> takes <code>page=2</code> and <code>packages</code> takes <code>page=8</code>.</p> <p>In this way, <code>params</code> flow naturally from user into collection. When you are initializing collections in code, most likely you'll interact with collection classes instead of <code>get_collection</code>, so you can leave collection name empty and keep all <code>params</code>:</p> <pre><code>col = MyCollection(\"\", {...})\n</code></pre> <p>And when you must use <code>get_collection</code> with named collection, but want to pass all <code>params</code> into collection, you can easily add prefixes yoursef:</p> <pre><code>&gt;&gt;&gt; data = {\"a\": 1, \"b\": 2}\n&gt;&gt;&gt; name = \"my-collection\"\n&gt;&gt;&gt; col = get_collection(name, {f\"{name}:{k}\": v for k, v in data.items()})\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"b\": 2}\n</code></pre> <p>And to make it even simpler, <code>get_collection</code> accepts <code>prefix_params</code> as 3rd positional argument. When this flag is enabled, prefixes are added automatically, so you can achieve the same effect as in snippet above using short version:</p> <pre><code>&gt;&gt;&gt; col = get_collection(\"my-collection\", {\"a\": 1, \"b\": 2}, True)\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"structure/collection/#initialization","title":"Initialization","text":"<p>When a collection is created, it initializes services using service factories and service settings. <code>data</code> service is initialized using <code>Collection.DataFactory</code> class and <code>data_settings</code>, <code>serializer</code> is initialized using <code>Collection.SerializerService</code> and <code>serializer_settings</code>, etc.</p> <p>This logic creates a workflow for defining new collections. Create a subclass of base Collection and override <code>*Factory</code> of this new class.</p> <p>Example</p> <pre><code>class MyCollection(collection.Collection):\n    DataFactory = data.StaticData\n</code></pre> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; isinstance(col.data, data.StaticData)\nTrue\n</code></pre> <p>Now you only need to find a suitable class for the service and job is done.</p> <p>But as soon as you choose the class, you'll notice, that majority of service factories must be configured before using. For example, the <code>StaticData</code> used in the example above produces records using iterable source. And this iterable must be configured, or you'll get just empty list from <code>StaticData</code>:</p> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[]\n</code></pre> <p>Configuration for services can be specified using keyword-only arguments of the collection's constructor. Pass <code>&lt;SERVICE&gt;_settings</code> dictionary to collection and this dictionary will be used as service settings. <code>data_settings={...}</code> is passed to data service, <code>pager_settings={...}</code> is passed to pager service, etc.</p> <p>Iterable with items is controlled by <code>data</code> parameter of <code>StatiData</code>. And it means you need to pass <code>data_settings={\"data\": [1, 2, 3]}</code> to collection constructor, if you want to use <code>[1, 2, 3]</code> as a data collection.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; col = MyCollection(data_settings={\"data\": [1, 2, 3]})\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>Instead of specifying <code>data</code> every time, you can create a derived class from <code>StaticData</code> and replace the default value of <code>data</code>.</p> <p>Example</p> <pre><code>class MyData(data.StaticData):\n    data = [1, 2, 3]\n\nclass MyCollection(collection.Collection):\n    DataFactory = MyData\n</code></pre> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>New classes are created quite often with ckanext-collection. And every existing service has a shortcut for creating its derivable with customized attributes.</p> <p>Whenever you need to extend parent service and set <code>attr</code> to <code>value</code> in the child class, use <code>with_attributes</code> classmethod of the parent service.</p> <p>Example</p> <pre><code>MyData = data.StaticData.with_attributes(data=[1, 2, 3])\n\nclass MyCollection(collection.Collection):\n    DataFactory = MyData\n</code></pre> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>And, in the same way you can pass settings for services, you can also specify factories when collection is initialized. Every <code>&lt;SERVICE&gt;_factory</code> paramterer of the collection's constructor overrides corresponding factory of the collection: <code>data_factory=StaticData</code> sets <code>DataFactory = StaticData</code>, <code>serializer_factory=CsvSerializer</code> sets <code>SerializerFactory = CsvSerializer</code>, etc.</p> <p>Example</p> <p>Instead of creating a new classes from previous examples, you could use the following code:</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": [1, 2, 3]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>Or even:</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData.with_attributes(\n&gt;&gt;&gt;         data=[1, 2, 3],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>This form is convenient when you experimenting with collections or creating them dynamically. But more often you'll create a separate class for collection and services. Using separate classes is more readable and flexible, as you keep all the derived classes and can combine/reuse them in future.</p> <p>Warning</p> <p><code>*_factory</code> accepts a class that can be used to initialize the service. You can use <code>data.StaticData</code>, because it's a class. Or you can use <code>data.StaticData.with_attributes(data=[1, 2, 3])</code>, because this method creates a new class.</p> <p>But you cannot use <code>data_factory=data.StaticData()</code> with parenthesis, because in this way you create an instance of the service and this instance cannot be used to initialize another instance.</p> <p>Remember: factory is a class; service is an object of this class.</p>"},{"location":"structure/collection/#usage","title":"Usage","text":"<p>Collections are not very impressive. You literally can create the collection and then you can iterate over a single page of collection results. But this must be exactly what you are doing most of the time. In a well defined collection, you don't need to access any services, apart from serializer.</p> <p>Let's use collection of all users from DB.</p> <p>Definition of collection</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Users(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(\n        model=model.User,\n        is_scalar=True,\n    )\n</code></pre> <p>Initialize this collection without arguments to work with 1st-10th users <code>users = Users()</code>.</p> <p>You can use direct access to data service to get users from 11th: <code>users.data[10:20]</code>. But you can also initialize the collection for the second page: <code>users = Users(pager_settings={\"page\": 2})</code>.</p> <p>If you know that you'll process more than 10 users at once, it's still possible to avoid direct access to data. Just set <code>rows_per_page</code> option of the pager: <code>users = Users(pager_settings={\"rows_per_page\": 100})</code></p> <p>Tip</p> <p><code>ModelData</code> supports search by filterable columns. For example, if you want to search users by <code>sysadmin</code> flag, configure columns service and add <code>sysadmin</code> to the <code>Columns.filterable</code>:</p> <pre><code>&gt;&gt;&gt; sysadmins = Users(\n&gt;&gt;&gt;     \"\",\n&gt;&gt;&gt;     {\"sysadmin\": True},\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(filterable={\"sysadmin\"})\n&gt;&gt;&gt; )\n&gt;&gt;&gt; all(user.sysadmin for user in sysadmins)\nTrue\n</code></pre> <p>Obviously, you can just create plain collection of users and pick sysadmins manually, iterating over <code>users.data</code>. And it would be absolutely normal solution, that works with any collection.</p> <pre><code>&gt;&gt;&gt; sysadmins = [\n&gt;&gt;&gt;     user for user in Users()\n&gt;&gt;&gt;     if user.sysadmin\n&gt;&gt;&gt; ]\n</code></pre> <p>But some services have more efficient ways to work with data, other than naive iteration. In case of <code>ModelData</code>, specifying <code>Columns.filterable</code> and using params of collection to filter the data produces optimized SQL query that fetches only required rows from DB.</p> <p>Always check documentation of the collection and its services and there is a chance that you'll find more efficient solution of your problem.</p>"},{"location":"structure/collection/#replacing-the-service","title":"Replacing the service","text":"<p>Warning</p> <p>This functionality is experimental and can change in future. Use it only if you see no other ways to achieve the result.</p> <p>It's possible to replace collection services after collection initialized. There are two ways to do it: by creating a new instance of the service and by expropriation service from the different collection.</p> <p>Creating a new service is staightforward. Service's constructor accepts collection as first positional argument and unlimited number of keyword-only arguments which are collected as service's settings.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; new_service = data.StaticData(col, data=[1, 2, 3])\n&gt;&gt;&gt; new_service is col.data\nTrue\n</code></pre> <p>The above example approximately the same as the following code</p> <pre><code>col = collection.Collection(\n    data_factory=data.StaticData,\n    data_settings={\"data\": [1, 2, 3]},\n)\n</code></pre> <p>When a new service is created, old service instance is discarded and the new one is attached to the collection. As you can see in the example, there is no need to assign the service into collection's <code>data</code> attribute. We just initialize the service and it automatically got into the right place.</p> <p>Warning</p> <p>Never use discarded service. It still has references to its parent collection, but collection itself does not recognize the discarded service anymore. This one-way reference often produce strange behavior.</p> <p>Reusing service from the existing collection is also simple. Just call <code>replace_service</code> of the new collection, that will take the service, and pass into it service that must be attached to collection.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; src = collection.Collection(data_factory=data.StaticData)\n&gt;&gt;&gt; dest = collection.Collection()\n&gt;&gt;&gt; dest.replace_service(src.data)\n&gt;&gt;&gt; isinstance(dest.data, data.StaticData)\nTrue\n</code></pre> <p><code>replace_service</code> also detaches old service and attaches the new one to collection. And, on top of this, the new service is detached from its original collection. It makes original collection unusable, unless you give it a new service instance instead.</p> <p>Warning</p> <p>Collection that lost its service because it was transfered to another collection, must not be used anymore. Just as with detached services, old collection still contains reference to its detached service, but service becomes the part of different collection and has no back reference to old collection. Using collection with such kind of one-way reference to service ofter produces strange behavior.</p> <p>If you want to use collection that lost its service, initialize a new service that will replace the old instance:</p> <pre><code>src = collection.Collection(data_factory=data.StaticData)\ndest = collection.Collection()\ndest.replace_service(src.data)\n\n# right now `src` cannot be used\n\ndata.StaticData(src)\n\n# now `src` got a new data service and it can be used again\n</code></pre>"},{"location":"structure/columns/","title":"Columns","text":""},{"location":"structure/columns/#overview","title":"Overview","text":"<p>This service contains additional information about separate columns of data records. It defines following settings:</p> <ul> <li>names: all available column names. Used by other settings of columns service</li> <li>hidden: <code>names</code> members that should not be serialized</li> <li>visible: <code>names</code> members that must be serialized</li> <li>sortable: <code>names</code> members that support sorting</li> <li>filterable: <code>names</code> members that support filtration/facetting</li> <li>searchable: <code>names</code> members that support search by partial match</li> <li>labels: human readable labels for <code>names</code> members</li> </ul> <p>There are not rules regarding usage of this service. Any serializer, data service or any other service can use information from the columns service or ignore it.</p> <p>You can also add more properties to this service. For example, if you want to use specific order of columns inside your custom implementation of CSV serializer, you can add <code>order</code> attribute to the columns service and read it during serialization.</p> <p>If you are not going to share your custom services, you can ignore columns service. Otherwise, it's recommended to keep any column-related options here.</p> <p>For example, almost all built-in serializers of ckanext-collection use <code>visible</code>/<code>hidden</code> attributes of the columns service to include/exclude certain fields into serialization output. In this way you can switch to a different serializer with a minimal amount of setings and receive the same set of fields serialized into a different format.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData.with_attributes(model=model.User),\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names={\"name\", \"id\", \"sysadmin\"},\n&gt;&gt;&gt;         hidden={\"id\"},\n&gt;&gt;&gt;     )\n&gt;&gt;&gt; )\n&gt;&gt;&gt; serialize.CsvSerializer(col).serialize()\nname,sysadmin\ndefault,True\n&gt;&gt;&gt; serialize.JsonSerializer(col).serialize()\n[{\"sysadmibn\": true, \"name\": \"default\"}]\n</code></pre>"},{"location":"structure/columns/#available-columns-factories","title":"Available columns factories","text":""},{"location":"structure/columns/#collection.shared.columns.Columns","title":"<code>Columns</code>","text":"<p>Collection of columns details for filtering/rendering.</p> ATTRIBUTE DESCRIPTION <code>names</code> <p>list of all available columns</p> <p> TYPE: <code>list[str]</code> </p> <code>visible</code> <p>columns that can be viewed</p> <p> TYPE: <code>set[str]</code> </p> <code>sortable</code> <p>columns that can be sorted</p> <p> TYPE: <code>set[str]</code> </p> <code>filterable</code> <p>columns that can be filtered using exect match</p> <p> TYPE: <code>set[str]</code> </p> <code>searchable</code> <p>columns that can be searched by partial match</p> <p> TYPE: <code>set[str]</code> </p> <code>labels</code> <p>UI labels for columns</p> <p> TYPE: <code>dict[str, str]</code> </p>"},{"location":"structure/data/","title":"Data","text":""},{"location":"structure/data/#overview","title":"Overview","text":"<p>This service produces the data for collection. Every data service must:</p> <ul> <li>be <code>Iterable</code></li> <li>yield all existing records during iteration. I.e, if data service produces   datasets from <code>package_search</code> API, <code>list(data)</code> must contain all   datasets from the search index, not only first 10 or 20.</li> <li>define <code>total</code> property, that reflects number of available records so that   <code>len(list(data)) == data.total</code></li> <li>define <code>range(start: Any, end: Any)</code> method that returns slice of the data</li> </ul> <p>Base class for data services - <code>Data</code> - already contains a simple version of this logic. Just override <code>compute_data()</code> and return a sequence with records from it, to satisfy minimal requirements of the data service.</p> <p>Example</p> <pre><code>class MyData(data.Data):\n    def compute_data(self):\n        return \"abcdefghijklmnopqrstuvwxyz\"\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; list(col)\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]\n&gt;&gt;&gt; col.data.total\n26\n&gt;&gt;&gt; col.data.range(-3, None)\n\"xyz\"\n</code></pre> <p>Using <code>compute_data</code> simplifies defining data services, but it's not required. You can explicitly implement all methods</p> <p>Example</p> <pre><code>class MyData(data.Data):\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\n\n    @property\n    def total(self):\n        return len(self.letters)\n\n    def __iter__(self):\n        yield from self.letters\n\n    def range(self, start, end):\n        return self.letters[start:end]\n</code></pre>"},{"location":"structure/data/#base-data-class","title":"Base <code>Data</code> class","text":"<p>This class defines a couple of standard helpers in addition to minimal requirements of data service</p> <p>The most important, it caches result of <code>compute_data</code> when data or data length is accessed. Because of it, items and length of the data service are not updated in runtime.</p> <p>Example</p> <p>In the following example, items from data service and its length are not changed after assigning to <code>items</code>, because of <code>compute_data</code> called only during first access to data. After this point, data service uses cached result of the first <code>compute_data</code> call.</p> <p><pre><code>class MyData(data.Data):\n    items = [1, 2, 3]\n\n    def compute_data(self):\n      return self.items\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; list(col.data)\n[1, 2, 3]\n&gt;&gt;&gt; col.data.total\n3\n&gt;&gt;&gt; col.data.items = [] # (1)!\n&gt;&gt;&gt; list(col.data)\n[1, 2, 3]\n&gt;&gt;&gt; col.data.total\n3\n</code></pre></p> <ol> <li>This has no sense, because data is already cached and <code>items</code> property will    not be used anymore</li> </ol> <p>To reset the cache and use <code>compute_data</code> again, call <code>refresh_data()</code> method of the data service.</p> <pre><code>&gt;&gt;&gt; col.data.items = \"hello\"\n&gt;&gt;&gt; col.data.refresh_data()\n&gt;&gt;&gt; list(col.data)\n[\"h\", \"e\", \"l\", \"l\", \"o\"]\n&gt;&gt;&gt; col.data.total\n5\n</code></pre> <p>Base <code>Data</code> class expects that <code>compute_data</code> returns a <code>collections.abc.Sequence</code>. With this expectation it implements <code>range(start, end)</code> that returns slice of the data, and <code>at(index)</code> that returns element with specified index.</p> <p>Example</p> <pre><code>class MyData(data.Data):\n    def compute_data(self):\n       return \"hello world\"\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; col.data.at(4)\n\"o\"\n&gt;&gt;&gt; col.data.range(6, None)\n\"world\"\n</code></pre> <p>These methods are also accessible via index operator.</p> <pre><code>&gt;&gt;&gt; col.data[4]\n\"o\"\n&gt;&gt;&gt; col.data[6:]\n\"world\"\n</code></pre> <p>If you are not going to rely on <code>compute_data</code> when extending <code>Data</code> class, implement your own caching logic and index-acces, if you need them.</p>"},{"location":"structure/data/#available-data-factories","title":"Available data factories","text":"<p>These factories are available at <code>ckanext.collection.shared.data</code>.</p>"},{"location":"structure/data/#collection.shared.data.Data","title":"<code>Data</code>","text":"<p>Base data source for collection.</p> <p>This class defines an outline of the data service. In basic case, sublcass should override <code>compute_data</code> method and return a Sequence from it to keep all methods functional.</p> Example <pre><code>class MyData(data.Data):\n    def compute_data(self):\n        return range(1, 20)\n</code></pre>"},{"location":"structure/data/#collection.shared.data.StaticData","title":"<code>StaticData</code>","text":"<p>Static data source.</p> <p>This class produce items from its <code>data</code> attribute. Use any sequence as a value for <code>data</code> during initialization.</p> Warning <p>Iteration and size measurement uses cached version of <code>data</code>. If <code>data</code> attribute was overriden after service initialization, call <code>refresh_data()</code> method of the service to reset the cache.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>sequence of items produced by the service</p> <p> TYPE: <code>Iterable[TData]</code> </p> Example <p><pre><code>NumericData = data.StaticData.with_attributes(data=range(1, 20))\n\nUppercaseData = data.StaticData.with_attributes(\n    data=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n)\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=NumericData)\n&gt;&gt;&gt; list(col)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre></p>"},{"location":"structure/data/#collection.shared.data.CsvFileData","title":"<code>CsvFileData</code>","text":"<p>Data source for CSV file.</p> <p>CSV file available at path specified by <code>source</code> attribute of the service is read into memory and its every row transformed into dictionary.</p> Warning <p>Iteration and size measurement uses cached version of source's content. If <code>source</code> attribute was overriden or its content was modified after service initialization, call <code>refresh_data()</code> method of the service to reset the cache.</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>path to CSV source</p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.CsvFileData,\n&gt;&gt;&gt;     data_settings={\"source\": \"/path/to/file.csv\"},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[\n    {\"column_1\": \"value_1\", \"column_2\": \"value_2\"},\n    ...\n]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.ApiData","title":"<code>ApiData</code>","text":"<p>API data source.</p> <p>This base class is suitable for building API calls. Its <code>compute_data</code> makes the single request to the specified API action and yields items from the response.</p> Warning <p>Iteration and size measurement uses cached version of action's result. To call action again and use the fresh result, use <code>refresh_data()</code> method of the service.</p> ATTRIBUTE DESCRIPTION <code>action</code> <p>API action that returns the data</p> <p> TYPE: <code>str</code> </p> <code>payload</code> <p>parameters passed to the action</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>ignore_auth</code> <p>skip authorization checks</p> <p> TYPE: <code>bool</code> </p> <code>user</code> <p>name of the user for the action. Default: <code>tk.current_user.name</code></p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ApiData,\n&gt;&gt;&gt;     data_settings={\"action\": \"group_list_authz\", \"user\": \"default\"},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[{...}, {...}]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.ApiSearchData","title":"<code>ApiSearchData</code>","text":"<p>               Bases: <code>ApiData[TData, TDataCollection]</code></p> <p>API data source optimized for package_search-like actions.</p> <p>This class expects that API action accepts <code>start</code> and <code>rows</code> parameters that controls offset and limit. And result of the action must contain <code>count</code> and <code>results</code> keys.</p> <p>This data service can iterate over huge number of items, reading just few of them into the memory at once. It means you can iterate over thousands of datasets in an efficient way without messing with offsets and limits:</p> <pre><code>packages = collection.Collection(\n    data_factory=data.ApiSearchData,\n    data_settings={\"action\": \"package_search\"},\n)\n\n# the following loop goes over every available package, no matter how may\n# of them are available inside search index\nfor pkg in packages.data: # (1)!\n    ...\n\n# total number of items processed in the previous step is the same as\n# number of public datasets\nassert packages.data.total == tk.get_action(\"package_search\")({}, {})[\"count\"]\n</code></pre> <ol> <li><code>data</code> service is iterated directly to access all the items. Iterating    over <code>packages</code> would yield just first 10 items because of pagination.</li> </ol> Warning <p>Size measurement uses cached number of records. To refresh the total number of records, call <code>refresh_data()</code> method of the service. Such thing can be used if a new item was created after initialization of the collection</p> <p>The records are not cached, to reduce memory usage. Every separate iteration over data service and every <code>range</code> call initiates a fresh API request.</p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ApiSearchData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"action\": \"package_search\",\n&gt;&gt;&gt;         \"payload\": {\"q\": \"res_format:CSV\"},\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[{...}, {...}]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.BaseSaData","title":"<code>BaseSaData</code>","text":"<p>Abstract data source for SQL statements.</p> <p>This class can be extended to build data source over SQL statement. Its <code>compute_data</code> calls 4 methods:</p> <ul> <li><code>get_base_statement</code>: produces initial statement</li> <li><code>alter_statement(stmt)</code>: modifies statement or replaces it completely</li> <li><code>statement_with_filters(stmt)</code>: apply <code>WHERE</code> and <code>HAVING</code> conditions</li> <li><code>statement_with_sorting(stmt)</code>: apply <code>ORDER BY</code></li> </ul> <p>These methods do nothing by default, but can be replaced in sublcasses to build SQL statement gradually.</p> Warning <p>Final statement produced by <code>compute_data</code> and total number of results are cached. Call <code>refresh_data()</code> method of the service to rebuild the statement and refresh number of rows.</p> ATTRIBUTE DESCRIPTION <code>use_naive_filters</code> <p>search by filterable columns from <code>params</code>. Default: true</p> <p> TYPE: <code>bool</code> </p> <code>use_naive_search</code> <p>if <code>params</code> contains <code>q</code>, ILIKE it against searchable columns. Default: true</p> <p> TYPE: <code>bool</code> </p> <code>session</code> <p>SQLAlchemy session</p> <p> TYPE: <code>AlchemySession</code> </p> <code>is_scalar</code> <p>return only first column from each row</p> <p> TYPE: <code>bool</code> </p> Example <pre><code>import sqlalchemy as sa\nfrom ckan import model\n\nclass UserData(data.BaseSaData):\n    def get_base_statement(self):\n        return sa.select(model.User.name)\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=UserData)\n&gt;&gt;&gt; list(col)\n[(\"default\",), (...,)]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.TemporalSaData","title":"<code>TemporalSaData</code>","text":"<p>               Bases: <code>BaseSaData[TStatement, TData, TDataCollection]</code></p> <p>Data source that supports pagination by datetime column.</p> ATTRIBUTE DESCRIPTION <code>temporal_column</code> <p>column used for pagination</p> <p> TYPE: <code>ColumnElement[Any]</code> </p> Example <p>This class can be used as a base for SQL statement based data services. Collection that uses such data service must also use <code>pager.TemporalPager</code> instead of the default <code>pager.ClassicPager</code>.</p> <pre><code>import sqlalchemy as sa\nfrom datetime import date, timedelta\nfrom ckan import model\n\nclass TemporalPackageData(data.TemporalSaData):\n    def get_base_statement(self):\n        return sa.select(model.Package.name, model.Package.metadata_created)\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=TemporalPackageData,\n&gt;&gt;&gt;     data_settings={\"temporal_column\": model.Package.metadata_created},\n&gt;&gt;&gt;     pager_factory=pager.TemporalPager,\n&gt;&gt;&gt;     pager_settings={\"since\": datetime.now() - timedelta(days=40)},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"pkg1\", datetime.datetime(2024, 6, 13, 10, 40, 22, 518511)), ...]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.StatementSaData","title":"<code>StatementSaData</code>","text":"<p>               Bases: <code>BaseSaData[Select, TData, TDataCollection]</code></p> <p>Data source for arbitrary SQL statement.</p> Warning <p>Final statement produced by <code>compute_data</code> and total number of results are cached. Call <code>refresh_data()</code> method of the service to rebuild the statement and refresh number of rows.</p> ATTRIBUTE DESCRIPTION <code>statement</code> <p>select statement</p> <p> TYPE: <code>Select</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StatementSaData,\n&gt;&gt;&gt;     data_settings={\"statement\": sa.select(model.User.name)},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"default\",), (...,)]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.UnionSaData","title":"<code>UnionSaData</code>","text":"<p>               Bases: <code>BaseSaData[Select, TData, TDataCollection]</code></p> <p>Data source for multiple SQL statement merged with UNION ALL.</p> Warning <p>Final statement produced by <code>compute_data</code> and total number of results are cached. Call <code>refresh_data()</code> method of the service to rebuild the statement and refresh number of rows.</p> ATTRIBUTE DESCRIPTION <code>statements</code> <p>select statements</p> <p> TYPE: <code>Select</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.UnionSaData,\n&gt;&gt;&gt;     data_settings={\"statements\": [\n&gt;&gt;&gt;         sa.select(model.User.name, sa.literal(\"user\")),\n&gt;&gt;&gt;         sa.select(model.Package.name, sa.literal(\"package\")),\n&gt;&gt;&gt;         sa.select(model.Group.name, sa.literal(\"group\")),\n&gt;&gt;&gt;     ]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"default\", \"user\"),\n(\"warandpeace\", \"package\"),\n(\"my-cool-group\", \"group\")]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.ModelData","title":"<code>ModelData</code>","text":"<p>               Bases: <code>BaseSaData[Select, TData, TDataCollection]</code></p> <p>Data source for SQLAlchemy model.</p> Warning <p>Final statement produced by <code>compute_data</code> and total number of results are cached. Call <code>refresh_data()</code> method of the service to rebuild the statement and refresh number of rows.</p> ATTRIBUTE DESCRIPTION <code>model</code> <p>main model used by data source</p> <p> TYPE: <code>Any</code> </p> <code>is_scalar</code> <p>return model instance instead of collection of columns.</p> Example <p>Non-scalar collection returns rows as tuples of columns <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"model\": model.User,\n&gt;&gt;&gt;         \"is_scalar\": False,\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"id-123-123\", \"user-name\", ...), ...]\n</code></pre></p> <p>Scalar collection yields model instances <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"model\": model.User,\n&gt;&gt;&gt;         \"is_scalar\": True,\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[&lt;User id=id-123-123 name=user-name&gt;, ...]\n</code></pre></p> <p> TYPE: <code>Any</code> </p> <code>static_columns</code> <p>select only specified columns. If <code>is_scalar</code> flag enabled, only first columns from this list is returned.</p> Example <p>Non-scalar collection with <code>static_columns</code> produces tuples with values <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"model\": model.User,\n&gt;&gt;&gt;         \"is_scalar\": False,\n&gt;&gt;&gt;         \"static_columns\": [model.User.name, model.User.sysadmin],\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"default\", True), ...]\n</code></pre></p> <p>Scalar collection with <code>static_columns</code> yields values of the first column <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"model\": model.User,\n&gt;&gt;&gt;         \"is_scalar\": True,\n&gt;&gt;&gt;         \"static_columns\": [model.User.name, model.User.sysadmin],\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[\"default\", ...]\n</code></pre></p> <p> TYPE: <code>list[Column[Any] | Label[Any]]</code> </p> <code>static_filters</code> <p>apply filters to the select statement</p> Example <p>Filters are values produced by operations with model columns. The same thing you'd pass into <code>.filter</code>/<code>.where</code> methods.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"model\": model.User,\n&gt;&gt;&gt;         \"is_scalar\": True,\n&gt;&gt;&gt;         \"static_filters\": [model.User.sysadmin == True],\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[&lt;User sysadmin=True ...&gt;, ...]\n</code></pre> <p> TYPE: <code>list[Any]</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User, \"is_scalar\": True},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[&lt;User ...&gt;, ...]\n</code></pre>"},{"location":"structure/domain/","title":"Abstract service","text":"<p>It's a concept, not a real service. This concept is used as a base by absolutely every service of any collection. And if you decide to introduce a brand new service, it will extend the base abstract service.</p> <p>Because this abstract service is used by every service type, it defines a number of standard traits of every service. Everything you'll learn in this chapter can be applied to every service you see in a real application.</p>"},{"location":"structure/domain/#service","title":"Service","text":"<p>The abstract service actually consists of two classes. The first one is <code>types.Service</code>. This is an abrstract class, which contains abstract property <code>service_name</code>. The property identifies the name of the service inside the collection.</p> <p>The base <code>data.Data</code> class implements <code>types.Service</code> and its implementation of <code>service_name</code> returns <code>data</code>. The base <code>serialize.Serializer</code> has <code>service_name</code> that returns <code>serializer</code>. And every other type of service does similar thing.</p> <p>Because of this, collection knows, where to put the service in the following code snippet:</p> <pre><code>src = collection.Collection(data_factory=data.StaticData)\ndest = collection.Collection()\ndest.replace_service(src.data)\n</code></pre> <p>We don't tell collection, that we are replacing the data service. But because the object passed into <code>replace_service</code> has <code>service_name</code> property, collection can recognize it and assign into correct attribute.</p> <p>If someone create a service that provides Solr connection, this service will get <code>service_name</code> property with value <code>solr</code>. And because of it, collection will keep any instance of such service as <code>col.solr</code>.</p>"},{"location":"structure/domain/#domain","title":"Domain","text":"<p>The second component of abstract service is <code>Domain</code>. <code>Domain</code> and <code>types.Service</code> are always used together. Every non-abstract service is subclassed from both <code>Domain</code> and <code>types.Service</code>.</p> <p><code>Domain</code> provides a set of convenient features for services.</p> <p>First, and probably most important, it defines the constructor of service as method with one positional-only argument(the collection) and any number of keyword-only arguments(settings). Thanks to <code>Domain</code>, when service is initialized, it's automatically attached to collection.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; data.StaticData(col)\n&gt;&gt;&gt; isinstance(col.data, data.StaticData)\nTrue\n</code></pre> <p>Settings are processed in a special way and will be described further inside settings section.</p> <p><code>Domain</code> exposes collection as <code>attached</code> property of the service. This is the two-way reference: collection contains link to its services and every service contains a link to the collection.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; col.data.attached is col\nTrue\n&gt;&gt;&gt; col.columns.attached is col\nTrue\n&gt;&gt;&gt; col.pager.attached is col\nTrue\n</code></pre> <p>And <code>Domain</code> provides <code>with_attributes</code> classmethod inside service. This method creates a subclass of the caller with overridden attributes.</p> <pre><code>&gt;&gt;&gt; MyData = data.Data.with_attributes(a=1, b=2)\n&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; col.data.a\n1\n&gt;&gt;&gt; col`.data.b\n2\n</code></pre>"},{"location":"structure/domain/#settings","title":"Settings","text":"<p>Service settings are passed as keyword-only arguments to service constructor or as <code>&lt;SERVICE&gt;_settings</code> dictionary to collection constructor. In both cases settings are processed in the same way. Service keeps known parameters and ignores everything else.</p> <p>That's a rule. Service does not keeps all the settings, it stores only settings that are registered inside the service.</p> <p>Example</p> <p>As <code>Data</code> has no settings, the whole <code>data_settings</code> is ignored.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.Data,\n&gt;&gt;&gt;     data_settings={\"a\": 1, \"b\": 2, \"data\": [1, 2, 3]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; hasattr(col.data, \"a\")\nFalse\n&gt;&gt;&gt; hasattr(col.data, \"b\")\nFalse\n&gt;&gt;&gt; hasattr(col.data, \"c\")\nFalse\n</code></pre> <p>Every configurable attribute of the service must be registered first, and only then you can set it via settings.</p> <p>To register the attribute, you have to create it inside class definition. And its value must be generated by <code>configurable_attribute</code> function.</p> <p>Example</p> <pre><code>from ckanext.collection.shared import collection, data, configurable_attribute\n\nclass MyData(data.Data):\n    a = configurable_attribute(\"default a\") # (1)!\n    b = configurable_attribute(default_factory=lambda self: \"default b\") # (2)!\n    c = configurable_attribute() # (3)!\n</code></pre> <ol> <li>Positional argument is used as default value for the attribute</li> <li>Named <code>default_factory</code> accepts a function that receives the service    instance and returns default value of attribute.</li> <li>If no default provided, attribute becomes mandatory and will cause an    exception if missing during initialization of service.</li> </ol> <p><code>configurable_attribute</code> accepts either static default value or a function that produces default value. Such function must be passed via named argument <code>default_factory</code> and must accept the only parameter: the service itself. If <code>configurable_attribute</code> is called without arguments, it registers a required attribute and service cannot be initialized without this attribute.</p> <p>Warning</p> <p>It's not allowed to use other configurable attributes inside <code>default_factory</code> of configurable attribute. The initialization order of configurable attributes is not defined at the moment. There are not guarantees that referred attribute is already initialized when <code>default_factory</code> is called.</p> <p>Any configurable attribute can be assigned via settings. If you try using settings with the class from the example above, registered attributes will be picked and added to the service:</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=MyData,\n&gt;&gt;&gt;     data_settings={\"a\": 1, \"b\": 2, \"c\": [1, 2, 3]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.data.a\n1\n&gt;&gt;&gt; col.data.b\n2\n&gt;&gt;&gt; col.data.c\n[1, 2, 3]\n</code></pre> <p>Tip</p> <p><code>with_attributes</code> also can create configurable attributes.</p> <pre><code>from ckanext.collection.shared import data, configurable_attribute\n\nMyData = data.Data.with_attributes(\n    a=configurable_attribute(\"default a\"),\n    b=configurable_attribute(default_factory=lambda self: \"default b\"),\n    c=configurable_attribute(),\n)\n</code></pre>"},{"location":"structure/filters/","title":"Filters","text":"<p>This service used only by HTML table serializers at the moment. It has two configurable attributes <code>static_filters</code> and <code>static_actions</code>. <code>static_filters</code> are used for building search form for the data table. <code>static_actions</code> are not used, but you can put into it details about batch or record-level actions and use these details to extend one of standard serializers. For example, ckanext-admin-panel defines allowed actions (remove, restore, hide) for content and creates custom templates that are referring these actions.</p>"},{"location":"structure/pager/","title":"Pager","text":""},{"location":"structure/pager/#overview","title":"Overview","text":"<p>Pager service sets the upper and lower bounds on data used by collection. When collection is used in loops, it gets position of the first and last record from the pager and passes these values to <code>range</code> method of the data service. The result is iterated over.</p> <p>Collection uses ClassicPager by default. It implements pagination using <code>page</code> and <code>rows_per_page</code> parameters. These settings of the pager service are used to compute <code>pager.start</code> and <code>pager.end</code>.</p> <p>Default value of the <code>rows_per_page</code> is 10, and <code>page</code> is set to <code>1</code>.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": range(1, 100)},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.pager.start\n0\n&gt;&gt;&gt; col.pager.end\n10\n&gt;&gt;&gt; list(col)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre> <p>If <code>page</code> is passed to <code>pager_settings</code> of the collection, or directly to the pager constructor, it modifies <code>start</code> and <code>end</code>.</p> <pre><code>&gt;&gt;&gt; pager.ClassicPager(col, page=3)\n&gt;&gt;&gt; col.pager.start\n20\n&gt;&gt;&gt; col.pager.end\n30\n&gt;&gt;&gt; list(col)\n[21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n</code></pre> <p><code>rows_per_page</code> controls the max number of items for a single page.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": range(1, 100)},\n&gt;&gt;&gt;     pager_settings={\"rows_per_page\": 3, \"page\": 5},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.pager.start\n12\n&gt;&gt;&gt; col.pager.end\n15\n&gt;&gt;&gt; list(col)\n[13, 14, 15]\n</code></pre> <p>Pagination details are often mixed with data filters, so <code>ClassicPager</code>, used by default in Collection, check if <code>page</code> and <code>rows_per_page</code> are available in <code>params</code> of the collection. If so, these values are used instead of pager settings.</p> <p>Example</p> <p>In this example collection have different pager settings specified by <code>params</code>(second positional argument) and <code>pager_settings</code>. In such situation <code>params</code> have higher priority and <code>pager_settings</code> are ignored.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     \"\",\n&gt;&gt;&gt;     {\"rows_per_page\": 1, \"page\": 2}, # (1)!\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": range(1, 100)},\n&gt;&gt;&gt;     pager_settings={\"rows_per_page\": 3, \"page\": 5},  # (2)!\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.pager.start\n1\n&gt;&gt;&gt; col.pager.end\n2\n&gt;&gt;&gt; list(col)\n[2]\n</code></pre> <ol> <li><code>params</code> have higher priority and will be used by collection when present</li> <li><code>pager_settings</code> are not used because they conflict with <code>params</code></li> </ol>"},{"location":"structure/pager/#available-pager-factories","title":"Available pager factories","text":""},{"location":"structure/pager/#collection.shared.pager.Pager","title":"<code>Pager</code>","text":"<p>Base for pager service.</p> <p>This class must be extended by every implementation of the pager service.</p> Example <pre><code>class StaticPager(Pager):\n    @property\n    def start(self) -&gt; int:\n        return 0\n\n    @property\n    def end(self) -&gt; int:\n        return 10\n\n    @property\n    def size(self) -&gt; int:\n        return 10\n</code></pre>"},{"location":"structure/pager/#collection.shared.pager.ClassicPager","title":"<code>ClassicPager</code>","text":"<p>Page-number based pagination.</p> ATTRIBUTE DESCRIPTION <code>page</code> <p>current active page</p> <p> TYPE: <code>int</code> </p> <code>rows_per_page</code> <p>max number of items per page</p> <p> TYPE: <code>int</code> </p> <code>prioritize_params</code> <p>if <code>params</code> contain pagination details, use them instead of <code>pager_settings</code>. Defaults to True.</p> <p> TYPE: <code>bool</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": range(1, 100)},\n&gt;&gt;&gt;     pager_factory=pager.ClassicPager,\n&gt;&gt;&gt;     pager_settings={\"page\": 2, \"rows_per_page\": 5},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[6, 7, 8, 9, 10]\n</code></pre>"},{"location":"structure/pager/#collection.shared.pager.OffsetPager","title":"<code>OffsetPager</code>","text":"<p>Limit/offset based pagination.</p> ATTRIBUTE DESCRIPTION <code>offset</code> <p>number of items to skip</p> <p> TYPE: <code>int</code> </p> <code>limit</code> <p>max number of items per page</p> <p> TYPE: <code>int</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": range(1, 100)},\n&gt;&gt;&gt;     pager_factory=pager.OffsetPager,\n&gt;&gt;&gt;     pager_settings={\"offset\": 2, \"limit\": 3},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[3, 4, 5]\n</code></pre>"},{"location":"structure/pager/#collection.shared.pager.TemporalPager","title":"<code>TemporalPager</code>","text":"<p>Date based pagination.</p> <p>Data service of the collection that uses TemporalPager must implement <code>range</code> as <code>range(start: date | None, end: date | None)</code>.</p> ATTRIBUTE DESCRIPTION <code>since</code> <p>date of the oldest record(<code>&gt;=</code>)</p> <p> TYPE: <code>date | None</code> </p> <code>until</code> <p>date of the newest record(<code>&lt;</code>)</p> <p> TYPE: <code>date | None</code> </p> Example <p>Define data service that supports date ranges.</p> <pre><code>from datetime import datetime, timedelta\n\nclass TemporalModelData(data.TemporalSaData, data.ModelData):\n    pass\n</code></pre> <p>Initialize the collection</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=TemporalModelData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"model\": model.Package,\n&gt;&gt;&gt;         \"temporal_column\": model.Package.metadata_created,\n&gt;&gt;&gt;     },\n&gt;&gt;&gt;     pager_factory=pager.TemporalPager,\n&gt;&gt;&gt;     pager_settings={\"since\": datetime.now() - timedelta(days=1)},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(...package created yesterday), ...]\n</code></pre>"},{"location":"structure/serializer/","title":"Serializer","text":""},{"location":"structure/serializer/#overview","title":"Overview","text":"<p>Serializer converts data into textual, binary or any other alternative representation. For example, if you want to transform records produced by the <code>data</code> service of the collection into MessagePack, you should probably use serializer.</p> <p>Serializers are main users of columns service, because it contains details about specific data columns. And serializers often iterate data service directly(ignoring <code>range</code> method), to serialize all available records.</p> <p>The only required method for serializer is <code>serialize</code>. This method must return an data from <code>data</code> service transformed into format provided by serializer. For example, <code>JsonSerializer</code> returns string with JSON-encoded data.</p> <p>You are not restricted by textual or binary formats. Serializer that transforms data into pandas' DataFrame is completely valid version of the serializer.</p> <p>Example</p> <pre><code>from array import array\n\nclass ArraySerializer(serialize.Serializer):\n    def serialize(self):\n        result = array(\"i\")\n        for item in self.attached.data:\n            result.append(item)\n\n        return result\n\ncol = collection.StaticCollection(\n    serializer_factory=ArraySerializer,\n    data_settings={\"data\": [1, 2, 3]}\n)\nassert col.serializer.serialize() == array(\"i\", [1,2,3])\n</code></pre>"},{"location":"structure/serializer/#available-serializer-factories","title":"Available serializer factories","text":""},{"location":"structure/serializer/#collection.shared.serialize.Serializer","title":"<code>Serializer</code>","text":"<p>Base collection serializer.</p> <p>For any derived implementation, <code>serialize</code> must transfrom data of the collection into expected format.</p> Example <pre><code>&gt;&gt;&gt; class MySerializer(serialize.Serializer):\n&gt;&gt;&gt;     def stream(self):\n&gt;&gt;&gt;         for record in self.attached.data:\n&gt;&gt;&gt;             yield yaml.dump(record)\n&gt;&gt;&gt;\n&gt;&gt;&gt;     def serialize(self):\n&gt;&gt;&gt;         return \"---\\n\".join(self.stream())\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.DictListSerializer","title":"<code>DictListSerializer</code>","text":"<p>Convert data into a list of dictionaries.</p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.DictListSerializer,\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names=[\"name\", \"sysadmin\"],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\n[{'name': 'default', 'sysadmin': True}]\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.CsvSerializer","title":"<code>CsvSerializer</code>","text":"<p>Serialize collection into CSV document.</p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.CsvSerializer,\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names=[\"name\", \"sysadmin\"],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\nname,sysadmin\ndefault,True\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.JsonlSerializer","title":"<code>JsonlSerializer</code>","text":"<p>Serialize collection into JSONL lines.</p> ATTRIBUTE DESCRIPTION <code>encoder</code> <p><code>json.JSONEncoder</code> instance used for serialization</p> <p> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.JsonlSerializer,\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names=[\"name\", \"sysadmin\"],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\n{\"name: \"default\", \"sysadmin\": true}\n{\"name: \"normal_user\", \"sysadmin\": false}\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.JsonSerializer","title":"<code>JsonSerializer</code>","text":"<p>Serialize collection into single JSON document.</p> ATTRIBUTE DESCRIPTION <code>encoder</code> <p><code>json.JSONEncoder</code> instance used for serialization</p> <p> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.JsonSerializer,\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names=[\"name\", \"sysadmin\"],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\n[{\"name: \"default\", \"sysadmin\": true},\n {\"name: \"normal_user\", \"sysadmin\": false}]\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.HtmlSerializer","title":"<code>HtmlSerializer</code>","text":"<p>Serialize collection into HTML document.</p> ATTRIBUTE DESCRIPTION <code>main_template</code> <p>path to Jinja2 template for the collection</p> <p> TYPE: <code>str</code> </p> <code>record_template</code> <p>path to Jinja2 template for the individual record</p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.HtmlSerializer,\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": range(3)},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\n&lt;ul&gt;\n  &lt;li&gt;0&lt;/li&gt;\n  &lt;li&gt;1&lt;/li&gt;\n  &lt;li&gt;2&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.TableSerializer","title":"<code>TableSerializer</code>","text":"<p>               Bases: <code>HtmlSerializer[TDataCollection]</code></p> <p>Serialize collection into HTML table.</p> ATTRIBUTE DESCRIPTION <code>main_template</code> <p>path to template for the collection</p> <p> TYPE: <code>str</code> </p> <code>main_template</code> <p>path to template for the table wrapper</p> <p> TYPE: <code>str</code> </p> <code>record_template</code> <p>path to template for the individual record</p> <p> TYPE: <code>str</code> </p> <code>counter_template</code> <p>path to template for the item counter</p> <p> TYPE: <code>str</code> </p> <code>pager_template</code> <p>path to template for the table pagination widget</p> <p> TYPE: <code>str</code> </p> <code>form_template</code> <p>path to template for the search form</p> <p> TYPE: <code>str</code> </p> <code>filter_template</code> <p>path to template for filters block inside search form</p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.TableSerializer,\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names=[\"name\", \"sysadmin\"],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\n&lt;table&gt;...&lt;/table&gt;\n</code></pre>"},{"location":"structure/serializer/#collection.shared.serialize.HtmxTableSerializer","title":"<code>HtmxTableSerializer</code>","text":"<p>               Bases: <code>TableSerializer[TDataCollection]</code></p> <p>Serialize collection into HTML table powered by HTMX.</p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     serializer_factory=serialize.HtmxTableSerializer,\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(\n&gt;&gt;&gt;         names=[\"name\", \"sysadmin\"],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.serializer.serialize()\n&lt;table&gt;...&lt;/table&gt;\n</code></pre>"}]}