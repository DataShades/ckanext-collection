{"config":{"lang":["en"],"separator":"[\\s\\-\\.\\_]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#ckanext-collection","title":"ckanext-collection","text":"<p>Tools for building interfaces for data collections using declarative style.</p> <p>This extension simplifies describing series of items, such as datasets from search page, users registered on portal, rows of CSV file, tables in DB, etc. Once you defined the way of fetching items from data source, you'll get generic interface for pagination, search and displaying data in any format: HTML page, CSV document, JSON list, or any other custom format that you can describe.</p> <p>Read the documentation for a full user guide.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install the extension</p> <pre><code>pip install ckanext-collection\n</code></pre> <p>Add <code>collection</code> to the <code>ckan.plugins</code> setting in your CKAN config file</p> <p>Define the collection</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data, columns, serialize\n\n\n## collection of all resources from DB\nclass MyCollection(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(model=model.Resource)\n    # `names` controls names of fields exported by serializer\n    # further in this guide\n    ColumnsFactory = columns.Columns.with_attributes(names=[\"name\", \"size\"])\n\n## collection of all packages available via search API\nclass MyCollection(collection.Collection):\n    DataFactory = data.ApiSearchData.with_attributes(action=\"package_search\")\n    ColumnsFactory = columns.Columns.with_attributes(names=[\"name\", \"title\"])\n\n## collection of all records from CSV file\nclass MyCollection(collection.Collection):\n    DataFactory = data.CsvFileData.with_attributes(source=\"/path/to/file.csv\")\n    ColumnsFactory = columns.Columns.with_attributes(names=[\"a\", \"b\"])\n</code></pre> <p>Initialize collection object and work with data:</p> <pre><code># collection with first page of results(1st-10th items)\ncol = MyCollection()\nitems = list(col)\n\n# collection with third page of results(21st-30th items)\ncol = MyCollection(\"\", {\"page\": 3})\nitems = list(col)\n\n\n# alternatively, read all the items into memory at once, without pagination.\n# It may be quite expensive operation depending on number of items\ncol = MyCollection()\nitems = list(col.data)\n\n# or get the slice of data from 8th till 12th\nitems = list(col.data[8:12])\n\n# check total number of items in collection\nprint(col.data.total)\n</code></pre> <p>Serialize data using <code>Serializer</code> service:</p> <pre><code># JSON string\nserializer = serialize.JsonSerializer(col)\n\n# or CSV string\nserializer = serialize.CsvSerializer(col)\n\n# or python list of dictionaries\nserializer = serialize.DictListSerializer(col)\n\n\nprint(serializer.serialize())\n</code></pre>"},{"location":"#license","title":"License","text":"<p>AGPL</p>"},{"location":"configuration/","title":"Configuration","text":"<pre><code># Names of registered collections that are viewable by any visitor, including\n# anonymous.\n# (optional, default: )\nckanext.collection.auth.anonymous_collections =\n\n# Names of registered collections that are viewable by any authenticated\n# user.\n# (optional, default: )\nckanext.collection.auth.authenticated_collections =\n\n# Add HTMX asset to pages. Enable this option if you are using CKAN v2.10\n# (optional, default: false)\nckanext.collection.include_htmx_asset = false\n\n# Initialize CKAN JS modules every time HTMX fetches HTML from the server.\n# (optional, default: false)\nckanext.collection.htmx_init_modules = false\n\n# Import path for serializer used by CSV export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:CsvSerializer)\nckanext.collection.export.csv.serializer = ckanext.collection.utils.serialize:CsvSerializer\n\n# Import path for serializer used by JSON export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:JsonSerializer)\nckanext.collection.export.json.serializer = ckanext.collection.utils.serialize:JsonSerializer\n\n# Import path for serializer used by JSONl export endpoint.\n# (optional, default: ckanext.collection.utils.serialize:JsonlSerializer)\nckanext.collection.export.jsonl.serializer = ckanext.collection.utils.serialize:JsonlSerializer\n\n# Import path for serializer used by `format`-export endpoint.\n# (optional, default: )\nckanext.collection.export.&lt;format&gt;.serializer =\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Compatibility with core CKAN versions:</p> CKAN version Compatible? 2.9 no 2.10 yes 2.11 yes master yes <p>Install the extension: <pre><code>pip install ckanext-collection\n</code></pre></p> <p>Add <code>collection</code> to the <code>ckan.plugins</code> setting in your CKAN config file .</p>"},{"location":"integrations/","title":"Integrations","text":""},{"location":"integrations/#ckanext-admin-panel","title":"ckanext-admin-panel","text":"<p>To enable configuration form of ckanext-collection in the admin panel, enable the following arbitrary schema</p> <pre><code>scheming.arbitrary_schemas =\n    ckanext.collection:ap_config.yaml\n</code></pre>"},{"location":"interfaces/","title":"Interfaces","text":""},{"location":"interfaces/#icollection","title":"ICollection","text":"<p>Extend functionality of ckanext-collections.</p> Example <pre><code>import ckan.plugins as p\nfrom ckanext.collection import shared\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(shared.ICollection, inherit=True)\n\n    def get_collection_factories(self) -&gt; dict[str, CollectionFactory]:\n        return {...}\n</code></pre>"},{"location":"interfaces/#collection.interfaces.ICollection.get_collection_factories","title":"<code>get_collection_factories()</code>","text":"<p>Register named collection factories.</p> Example <pre><code>def get_collection_factories(self) -&gt; dict[str, CollectionFactory]:\n    return {\n        \"packages\": PackageCollection,\n    }\n</code></pre> RETURNS DESCRIPTION <code>dict[str, CollectionFactory]</code> <p>mapping of global collection name to collection factory</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#register-collection","title":"Register collection","text":"<p>Collection can be initialized anywhere in code</p> <p>Example</p> <pre><code>from my.module import MyCollection\n\ncol = MyCollection()\n</code></pre> <p>But it's recommended to register collections globally.</p> <p>Collections are registered via ICollection interface or via CKAN signals. Registered collection can be initialized anywhere in code using helper. It can also be used in a number of generic endpoints that render collection as HTML or export it into different formats.</p> Register via interfaceRegister via signal <pre><code>import ckan.plugins as p\nfrom ckanext.collection import shared\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(shared.ICollection, inherit=True)\n\n    def get_collection_factories(\n        self,\n    ) -&gt; dict[str, shared.types.CollectionFactory]:\n        return {\n            \"my-collection\": MyCollection,\n        }\n</code></pre> <pre><code>import ckan.plugins as p\n\nclass MyPlugin(p.SingletonPlugin):\n    p.implements(p.ISignal)\n\n    def get_signal_subscriptions(self) -&gt; types.SignalMapping:\n        return {\n            tk.signals.ckanext.signal(\"collection:register_collections\"): [\n                get_collection_factories,\n            ],\n        }\n\ndef get_collection_factories(sender: None): # (1)!\n    return {\n        \"my-collection\": MyCollection,\n    }\n</code></pre> <ol> <li>Signal listerners must receive at least one argument containing the sender    of the signal. Signal that register collections always sets <code>None</code> as a    sender.</li> </ol> <p><code>get_collection_factories</code> returns a dictionary with collection names(letters, digits, underscores and hyphens are allowed) as keys, and collection factories as values. In most generic case, collection factory is just a collection's class itself. But you can use any function with signature <code>(str, dict[str, Any], **Any) -&gt; Collection</code> as a factory.</p> <p>Example</p> <p>The following function is a valid collection factory and it can be returned from <code>get_collection_factories</code></p> <pre><code>def my_factory(name: str, params: dict[str, Any], **kwargs: Any):\n    \"\"\"Collection that shows 100 numbers per page\"\"\"\n    params.setdefault(\"rows_per_page\", 100)\n    return MyCollection(name, params, **kwargs)\n</code></pre>"},{"location":"usage/#initialize-collection","title":"Initialize collection","text":"<p>Collection class defines the data source of collection and different aspects of its behavior. But collection class itself does not contain any data and collection instance must be created to work with data.</p> <p>Any collection can be initialized directly, using collection class. And every registered collection can be initialized via <code>get_collection</code> function. Arguments are the same in both cases. Collection requires the name, parameters and accepts arbitrary number of keyword-only arguments, that are passed to underlying services.</p> Initialize registered collectionInitialize collection using class <pre><code>col = get_collection(\n    \"my-collection\",\n    {},\n    pager_settings={\"rows_per_page\": 100}\n)\n</code></pre> <p>Tip</p> <p>Second argument of <code>get_collection</code> expects parameters prefixed by collection name. In example above, to choose the second page, you need to pass <code>{\"my-collection:page\": 2}</code> as parameters.</p> <p>If you are using unprefixed parameters, like <code>{\"page\": 2}</code> and don't want to adapt them to expected form, pass <code>True</code> as the third argument to <code>get_collection</code>, and every key inside parameters will get required prefix automatically.</p> <pre><code>col = get_collection(\n    \"my-collection\",\n    {\"page\": 2},\n    True,\n    pager_settings={\"rows_per_page\": 100}\n)\n</code></pre> <pre><code>col = MyCollection(\n    \"\",\n    {},\n    pager_settings={\"rows_per_page\": 100},\n)\n</code></pre>"},{"location":"usage/#use-collection-data","title":"Use collection data","text":"<p>Tip</p> <p>If you want to try examples below, but you haven't defined any collection yet, you can use the following definition for collection of numbers from 1 to 25:</p> <pre><code>from ckanext.collection.shared import collection, data\nclass MyCollection(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=[\n        {\"number\": num, \"index\": idx}\n        for idx, num in enumerate(range(1,26))\n    ])\n</code></pre> <p>Intended way to access the data is iteration over collection instance. In this way, you access only specific chunk of data, limited by collection's pager.</p> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[{'number': 1, 'index': 0},\n {'number': 2, 'index': 1},\n {'number': 3, 'index': 2},\n {'number': 4, 'index': 3},\n {'number': 5, 'index': 4},\n {'number': 6, 'index': 5},\n {'number': 7, 'index': 6},\n {'number': 8, 'index': 7},\n {'number': 9, 'index': 8},\n {'number': 10, 'index': 9}]\n</code></pre> <p>Different page can be accessed by passing <code>page</code> inside params to collection's constructor</p> <pre><code>&gt;&gt;&gt; col = MyCollection(\"\", {\"page\": 3}) # (1)!\n&gt;&gt;&gt; list(col)\n[{'number': 21, 'index': 20},\n {'number': 22, 'index': 21},\n {'number': 23, 'index': 22},\n {'number': 24, 'index': 23},\n {'number': 25, 'index': 24}]\n</code></pre> <ol> <li>More idiomatic form of this initialization is <code>MyCollection(pager_settings={\"page\": 3}))</code>. But this form is longer an    required deeper knowledge of collections.</li> </ol> <p>If you need to iterate over all collection items, without pagination, you can use <code>data</code> attribute of the collection.</p> <p>Warning</p> <p>Using data directly can result in enormous memory consumption. Avoid transforming data into list(<code>list(col.data)</code>) or processing it as single object in any other way. Instead, iterate over collection items using loops or similar tools.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; sum = 0\n&gt;&gt;&gt; for item in col.data:\n&gt;&gt;&gt;     sum += item[\"number\"]\n&gt;&gt;&gt;\n&gt;&gt;&gt; print(sum)\n325\n</code></pre>"},{"location":"usage/#serialize-collection","title":"Serialize collection","text":"<p>The ultimate goal of every collection is serialization. It may be serialization as HTML to show collection on one of application web-pages. Or serialization as JSON to send collection to the external API. Or serialization as CSV to allow user downloading the collection. Or even serialization as pandas' DataFrame to process data from the collection using more advanced tools.</p> <p><code>serializer</code> service of collection is responsible for serialization. If required format of collections output is known in advance, <code>SerializerFactory</code> can be defined on collection level.</p> <p>If the format of serialization can vary, <code>serializer</code> can be initialized separately.</p> Using SerializerFactoryCreating serializers on demand <pre><code>from ckanext.collection.shared import collection, serialize, data\n\nclass MyCollection(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=[\n        {\"number\": num, \"index\": idx}\n        for idx, num in enumerate(range(1,26))\n    ])\n    SerializerFactory = serialize.CsvSerializer\n\ncol = MyCollection()\nprint(col.serializer.serialize())\n</code></pre> <pre><code>from ckanext.collection.shared import collection, serialize, data\n\nclass MyCollection(collection.Collection):\n    DataFactory = data.StaticData.with_attributes(data=[\n        {\"number\": num, \"index\": idx}\n        for idx, num in enumerate(range(1,26))\n    ])\n\n\ncol = MyCollection()\n\njson = serialize.JsonSerializer(col)\nprint(json.serialize())\n\ncsv = serialize.CsvSerializer(col)\nprint(csv.serialize())\n</code></pre> <p>Warning</p> <p>Keep in mind, as any other collection's service, serializer attaches itself to collection when initialized and replaces the previous serializer.</p> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; isinstance(col.serializer, serialize.Serializer)\nTrue\n&gt;&gt;&gt; serialize.JsonSerializer(col)\n&gt;&gt;&gt; isinstance(col.serializer, serialize.JsonSerializer)\nTrue\n&gt;&gt;&gt; serialize.CsvSerializer(col)\n&gt;&gt;&gt; isinstance(col.serializer, serialize.CsvSerializer)\nTrue\n</code></pre>"},{"location":"api/","title":"API","text":""},{"location":"structure/","title":"Structure of the collection","text":""},{"location":"structure/#introduction","title":"Introduction","text":"<p>Collections are designed to describe the data. Most common logic often can be defined declaratively and all imperative commands are ether hidden deep inside different parts of collection or injected as tiny lambda-functions.</p> <p>But describing the data is not simple, especially if data needs to be interactive. As result, collections have complex internal structure. Good news, you don't need to know everything in order to use the collections. As long as you need something simple, you can use the minimum of knowledge.</p> <p>Look how collection with all the users from DB can be created:</p> Using anonymous classes and verbose initializationUsing dedicated class and simple initialization <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection\n\nusers = collection.ModelCollection(data_settings={\"model\": model.User})\n</code></pre> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Users(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(model=model.User)\n\nusers = Users()\n</code></pre> <p>For most standard use-cases, ckanext-collection already contains a number of classes that do the heavy lifting. And in future, as more popular scenarios discovered, the number of classes will grow.</p> <p>Still, custom requirements are often appear in the project. Because of it, understanding how collection works and how it can be customized is the key point in building the perfect collection.</p>"},{"location":"structure/#collection","title":"Collection","text":"<p>Collection itself contains just a bare minimum of logic, and real magic happens inside its services. Collection knows how to initialize services and usually the only difference between all collections, is the way their services are configured.</p>"},{"location":"structure/#services","title":"Services","text":""},{"location":"structure/#data","title":"data","text":"<p>controls the exact data that can be received from collection. Contains logic for searching, filters, sorting, etc.</p>"},{"location":"structure/#pager","title":"pager","text":"<p>defines restrictions for data iteration. Exactly this service limits results to 10 records when you iterating over collection.</p>"},{"location":"structure/#serializer","title":"serializer","text":"<p>specifies how collection can be transformed into specific format. Using correct serializer you'll be able to dump the whole collection as CSV, JSON, YAML or render it as HTML table.</p>"},{"location":"structure/#columns","title":"columns","text":"<p>contains configuration of specific data columns used by other services. It may define model attributes that are dumped into CSV, names of the transformation functions that are applied to the certain attribute, names of the columns that are available for sorting in HTML representation of data.</p> <p>Mainly used by serializer(controls visibility of data fields) and data(controls ability to search, filter and sort by field) services.</p>"},{"location":"structure/#filters","title":"filters","text":"<p>contains configuration of additional widgets produced during data serialization. For example, when data is serialized into an HTML table, filters can define configuration of dropdowns and input fields from the data search form.</p> <p>Tip</p> <p>You can define more services in custom collections. The list above only enumerates the services available in the base collection.</p> <p>For example, one of built-in collections, <code>DbCollection</code> has additional service called <code>db_connection</code> that can communicate with DB.</p>"},{"location":"structure/collection/","title":"Collection","text":""},{"location":"structure/collection/#overview","title":"Overview","text":"<p>Collection works as a proxy between user and collection's services. It hides internal complexity and simplifies access to data.</p> <p>The very base collection contains no data. It can be initialized using <code>Collection</code> constructor.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; list(col)\n[]\n</code></pre> <p>Constructor of collection accepts two positional arguments:</p> <ul> <li><code>name</code>: string containing letters, numbers, underscores and hyphens</li> <li><code>params</code>: dictionary that can be used by services. There are no rules that   define, how exactly params are used and whether or not they are used at   all. Everything depends on services. For example, pager usually checks   <code>page</code> and <code>rows_per_page</code> inside <code>params</code>. Data service often uses fields   from <code>params</code> to filter data.</li> </ul> <p>Note</p> <p><code>params</code> depend on collection name. If the name is empty, params are used without changes. If name is not empty, params are filtered and transformed. First, any member of params that is not prefixed with collection name and colon is removed. Then, the prefix is removed.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\"\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}) # (1)!\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}\n&gt;&gt;&gt; col = collection.Collection(\"xxx\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}) # (2)!\n&gt;&gt;&gt; col.params\n{\"b\": 2}\n&gt;&gt;&gt; col = collection.Collection(\"yyy\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}) # (3)!\n&gt;&gt;&gt; col.params\n{\"c\": 3}\n</code></pre> <ol> <li>All parameter are kept because collection has no name.</li> <li>Only <code>xxx:b</code> is kept and its name transformed to just <code>b</code>, because    collection has name <code>xxx</code>.</li> <li>Only <code>yyy:c</code> is kept and its name transformed to just <code>c</code>, because    collection has name <code>yyy</code>.</li> </ol> Why <code>params</code> are transformed? <p>As long as collection is initialized manually and don't have a name, you don't need to think about <code>params</code> transformation.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\"\", {\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3})\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"xxx:b\": 2, \"yyy:c\": 3}\n</code></pre> <p>Transformation becomes important, whn you initialize registered named collection via <code>get_collection</code></p> <pre><code>&gt;&gt;&gt; col = get_collection(\n&gt;&gt;&gt;    \"my-collection\",\n&gt;&gt;&gt;    {\"a\": 1, \"my-collection:b\": 2},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.params\n{\"b\": 2}\n</code></pre> <p>This design decision was made to simplify rendering conllections on webpages.</p> <p>Imagine the page that renders <code>users</code> and <code>packages</code> collection. These collections are rendered as tables with pagination and view code looks like this:</p> <pre><code>import ckan.plugins.toolkit as tk\nfrom ckan.logic import parse_params\n\n@route(...)\ndef users_and_packages():\n    params = parse_params(tk.request.args)\n\n    users = get_collection(\"users\", params)\n    packages = get_collection(\"packages\", params)\n\n    return tk.render(template, {\n        \"users\": users,\n        \"packages\": packages,\n    })\n</code></pre> <p>Because <code>params</code> uses collection name as prefix, it's possible to paginate collections separately. Query string <code>?users:page=2&amp;packages:page=8</code> parsed into <code>params</code> dictionary on the first line of view. This dictionary contains both page values with prefixes. When <code>users</code> and <code>packages</code> collections initialized, they pick only relevant values from <code>params</code>, so <code>users</code> takes <code>page=2</code> and <code>packages</code> takes <code>page=8</code>.</p> <p>In this way, <code>params</code> flow naturally from user into collection. When you are initializing collections in code, most likely you'll interact with collection classes instead of <code>get_collection</code>, so you can leave collection name empty and keep all <code>params</code>:</p> <pre><code>col = MyCollection(\"\", {...})\n</code></pre> <p>And when you must use <code>get_collection</code> with named collection, but want to pass all <code>params</code> into collection, you can easily add prefixes yoursef:</p> <pre><code>&gt;&gt;&gt; data = {\"a\": 1, \"b\": 2}\n&gt;&gt;&gt; name = \"my-collection\"\n&gt;&gt;&gt; col = get_collection(name, {f\"{name}:{k}\": v for k, v in data.items()})\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"b\": 2}\n</code></pre> <p>And to make it even simpler, <code>get_collection</code> accepts <code>prefix_params</code> as 3rd positional argument. When this flag is enabled, prefixes are added automatically, so you can achieve the same effect as in snippet above using short version:</p> <pre><code>&gt;&gt;&gt; col = get_collection(\"my-collection\", {\"a\": 1, \"b\": 2}, True)\n&gt;&gt;&gt; col.params\n{\"a\": 1, \"b\": 2}\n</code></pre>"},{"location":"structure/collection/#initialization","title":"Initialization","text":"<p>When a collection is created, it initializes services using service factories and service settings. <code>data</code> service is initialized using <code>Collection.DataFactory</code> class and <code>data_settings</code>, <code>serializer</code> is initialized using <code>Collection.SerializerService</code> and <code>serializer_settings</code>, etc.</p> <p>This logic creates a workflow for defining new collections. Create a subclass of base Collection and override <code>*Factory</code> of this new class.</p> <p>Example</p> <pre><code>class MyCollection(collection.Collection):\n    DataFactory = data.StaticData\n</code></pre> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; isinstance(col.data, data.StaticData)\nTrue\n</code></pre> <p>Now you only need to find a suitable class for the service and job is done.</p> <p>But as soon as you choose the class, you'll notice, that majority of service factories must be configured before using. For example, the <code>StaticData</code> used in the example above produces records using iterable source. And this iterable must be configured, or you'll get just empty list from <code>StaticData</code>:</p> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[]\n</code></pre> <p>Configuration for services can be specified using keyword-only arguments of the collection's constructor. Pass <code>&lt;SERVICE&gt;_settings</code> dictionary to collection and this dictionary will be used as service settings. <code>data_settings={...}</code> is passed to data service, <code>pager_settings={...}</code> is passed to pager service, etc.</p> <p>Iterable with items is controlled by <code>data</code> parameter of <code>StatiData</code>. And it means you need to pass <code>data_settings={\"data\": [1, 2, 3]}</code> to collection constructor, if you want to use <code>[1, 2, 3]</code> as a data collection.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; col = MyCollection(data_settings={\"data\": [1, 2, 3]})\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>Instead of specifying <code>data</code> every time, you can create a derived class from <code>StaticData</code> and replace the default value of <code>data</code>.</p> <p>Example</p> <pre><code>class MyData(data.StaticData):\n    data = [1, 2, 3]\n\nclass MyCollection(collection.Collection):\n    DataFactory = MyData\n</code></pre> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>New classes are created quite often with ckanext-collection. And every existing service has a shortcut for creating its derivable with customized attributes.</p> <p>Whenever you need to extend parent service and set <code>attr</code> to <code>value</code> in the child class, use <code>with_attributes</code> classmethod of the parent service.</p> <p>Example</p> <pre><code>MyData = data.StaticData.with_attributes(data=[1, 2, 3])\n\nclass MyCollection(collection.Collection):\n    DataFactory = MyData\n</code></pre> <pre><code>&gt;&gt;&gt; col = MyCollection()\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>And, in the same way you can pass settings for services, you can also specify factories when collection is initialized. Every <code>&lt;SERVICE&gt;_factory</code> paramterer of the collection's constructor overrides corresponding factory of the collection: <code>data_factory=StaticData</code> sets <code>DataFactory = StaticData</code>, <code>serializer_factory=CsvSerializer</code> sets <code>SerializerFactory = CsvSerializer</code>, etc.</p> <p>Example</p> <p>Instead of creating a new classes from previous examples, you could use the following code:</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData,\n&gt;&gt;&gt;     data_settings={\"data\": [1, 2, 3]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>Or even:</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StaticData.with_attributes(\n&gt;&gt;&gt;         data=[1, 2, 3],\n&gt;&gt;&gt;     ),\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[1, 2, 3]\n</code></pre> <p>This form is convenient when you experimenting with collections or creating them dynamically. But more often you'll create a separate class for collection and services. Using separate classes is more readable and flexible, as you keep all the derived classes and can combine/reuse them in future.</p> <p>Warning</p> <p><code>*_factory</code> accepts a class that can be used to initialize the service. You can use <code>data.StaticData</code>, because it's a class. Or you can use <code>data.StaticData.with_attributes(data=[1, 2, 3])</code>, because this method creates a new class.</p> <p>But you cannot use <code>data_factory=data.StaticData()</code> with parenthesis, because in this way you create an instance of the service and this instance cannot be used to initialize another instance.</p> <p>Remember: factory is a class; service is an object of this class.</p>"},{"location":"structure/collection/#usage","title":"Usage","text":"<p>Collections are not very impressive. You literally can create the collection and then you can iterate over a single page of collection results. But this must be exactly what you are doing most of the time. In a well defined collection, you don't need to access any services, apart from serializer.</p> <p>Let's use collection of all users from DB.</p> <p>Definition of collection</p> <pre><code>from ckan import model\nfrom ckanext.collection.shared import collection, data\n\nclass Users(collection.Collection):\n    DataFactory = data.ModelData.with_attributes(\n        model=model.User,\n        is_scalar=True,\n    )\n</code></pre> <p>Initialize this collection without arguments to work with 1st-10th users <code>users = Users()</code>.</p> <p>You can use direct access to data service to get users from 11th: <code>users.data[10:20]</code>. But you can also initialize the collection for the second page: <code>users = Users(pager_settings={\"page\": 2})</code>.</p> <p>If you know that you'll process more than 10 users at once, it's still possible to avoid direct access to data. Just set <code>rows_per_page</code> option of the pager: <code>users = Users(pager_settings={\"rows_per_page\": 100})</code></p> <p>Tip</p> <p><code>ModelData</code> supports search by filterable columns. For example, if you want to search users by <code>sysadmin</code> flag, configure columns service and add <code>sysadmin</code> to the <code>Columns.filterable</code>:</p> <pre><code>&gt;&gt;&gt; sysadmins = Users(\n&gt;&gt;&gt;     \"\",\n&gt;&gt;&gt;     {\"sysadmin\": True},\n&gt;&gt;&gt;     columns_factory=columns.Columns.with_attributes(filterable={\"sysadmin\"})\n&gt;&gt;&gt; )\n&gt;&gt;&gt; all(user.sysadmin for user in sysadmins)\nTrue\n</code></pre> <p>Obviously, you can just create plain collection of users and pick sysadmins manually, iterating over <code>users.data</code>. And it would be absolutely normal solution, that works with any collection.</p> <pre><code>&gt;&gt;&gt; sysadmins = [\n&gt;&gt;&gt;     user for user in Users()\n&gt;&gt;&gt;     if user.sysadmin\n&gt;&gt;&gt; ]\n</code></pre> <p>But some services have more efficient ways to work with data, other than naive iteration. In case of <code>ModelData</code>, specifying <code>Columns.filterable</code> and using params of collection to filter the data produces optimized SQL query that fetches only required rows from DB.</p> <p>Always check documentation of the collection and its services and there is a chance that you'll find more efficient solution of your problem.</p>"},{"location":"structure/collection/#replacing-the-service","title":"Replacing the service","text":"<p>Warning</p> <p>This functionality is experimental and can change in future. Use it only if you see no other ways to achieve the result.</p> <p>It's possible to replace collection services after collection initialized. There are two ways to do it: by creating a new instance of the service and by expropriation service from the different collection.</p> <p>Creating a new service is staightforward. Service's constructor accepts collection as first positional argument and unlimited number of keyword-only arguments which are collected as service's settings.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; new_service = data.StaticData(col, data=[1, 2, 3])\n&gt;&gt;&gt; new_service is col.data\nTrue\n</code></pre> <p>The above example approximately the same as the following code</p> <pre><code>col = collection.Collection(\n    data_factory=data.StaticData,\n    data_settings={\"data\": [1, 2, 3]},\n)\n</code></pre> <p>When a new service is created, old service instance is discarded and the new one is attached to the collection. As you can see in the example, there is no need to assign the service into collection's <code>data</code> attribute. We just initialize the service and it automatically got into the right place.</p> <p>Warning</p> <p>Never use discarded service. It still has references to its parent collection, but collection itself does not recognize the discarded service anymore. This one-way reference often produce strange behavior.</p> <p>Reusing service from the existing collection is also simple. Just call <code>replace_service</code> of the new collection, that will take the service, and pass into it service that must be attached to collection.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; src = collection.Collection(data_factory=data.StaticData)\n&gt;&gt;&gt; dest = collection.Collection()\n&gt;&gt;&gt; dest.replace_service(src.data)\n&gt;&gt;&gt; isinstance(dest.data, data.StaticData)\nTrue\n</code></pre> <p><code>replace_service</code> also detaches old service and attaches the new one to collection. And, on top of this, the new service is detached from its original collection. It makes original collection unusable, unless you give it a new service instance instead.</p> <p>Warning</p> <p>Collection that lost its service because it was transfered to another collection, must not be used anymore. Just as with detached services, old collection still contains reference to its detached service, but service becomes the part of different collection and has no back reference to old collection. Using collection with such kind of one-way reference to service ofter produces strange behavior.</p> <p>If you want to use collection that lost its service, initialize a new service that will replace the old instance:</p> <pre><code>src = collection.Collection(data_factory=data.StaticData)\ndest = collection.Collection()\ndest.replace_service(src.data)\n\n# right now `src` cannot be used\n\ndata.StaticData(src)\n\n# now `src` got a new data service and it can be used again\n</code></pre>"},{"location":"structure/columns/","title":"Columns","text":"<p>This service contains additional information about separate columns of data records. It defines following settings:</p> <ul> <li>names: all available column names. Used by other settings of columns service</li> <li>hidden: columns that should not be shown by serializer. Used by serializer   services</li> <li>visible: columns that must be shown by serializer. Used by serializer   services</li> <li>sortable: columns that support sorting. Used by data services</li> <li>filterable: columns that support filtration/facetting. Used by data services</li> <li>searchable: columns that support search by partial match. Used by data   services</li> <li>labels: human readable labels for columns. Used by serializer services</li> </ul> <p>This service contains information used by other service, so defining additional attributes here is completely normal. For example, some custom serializer, that serializes data into ORC, can expect <code>orc_format</code> attribute in the <code>columns</code> service to be available. So you can add as much additional column related details as required into this service.</p>"},{"location":"structure/data/","title":"Data","text":""},{"location":"structure/data/#overview","title":"Overview","text":"<p>This service produces the data for collection. Every data service must:</p> <ul> <li>be <code>Iterable</code></li> <li>yield all existing records during iteration. I.e, if data service produces   datasets from <code>package_search</code> API, <code>list(data)</code> must contain all   datasets from the search index, not only first 10 or 20.</li> <li>define <code>total</code> property, that reflects number of available records so that   <code>len(list(data)) == data.total</code></li> <li>define <code>range(start: Any, end: Any)</code> method that returns slice of the data</li> </ul> <p>Base class for data services - <code>Data</code> - already contains a simple version of this logic. Just override <code>compute_data()</code> and return a sequence with records from it, to satisfy minimal requirements of the data service.</p> <p>Example</p> <pre><code>class MyData(data.Data):\n    def compute_data(self):\n        return \"abcdefghijklmnopqrstuvwxyz\"\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; list(col)\n[\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"]\n&gt;&gt;&gt; col.data.total\n26\n&gt;&gt;&gt; col.data.range(-3, None)\n\"xyz\"\n</code></pre> <p>Using <code>compute_data</code> simplifies defining data services, but it's not required. You can explicitly implement all methods</p> <p>Example</p> <pre><code>class MyData(data.Data):\n    letters = \"abcdefghijklmnopqrstuvwxyz\"\n\n    @property\n    def total(self):\n        return len(self.letters)\n\n    def __iter__(self):\n        yield from self.letters\n\n    def range(self, start, end):\n        return self.letters[start:end]\n</code></pre>"},{"location":"structure/data/#base-data-class","title":"Base <code>Data</code> class","text":"<p>This class defines a couple of standard helpers in addition to minimal requirements of data service</p> <p>The most important, it caches result of <code>compute_data</code> when data or data length is accessed. Because of it, items and length of the data service are not updated in runtime.</p> <p>Example</p> <p>In the following example, items from data service and its length is not changes after assigning to <code>items</code>, because of <code>compute_data</code> called only during first access to data. After this point, data service uses cached result of the first <code>compute_data</code> call.</p> <p><pre><code>class MyData(data.Data):\n    items = [1, 2, 3]\n\n    def compute_data(self):\n      return self.items\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; list(col.data)\n[1, 2, 3]\n&gt;&gt;&gt; col.data.total\n3\n&gt;&gt;&gt; col.data.items = [] # (1)!\n&gt;&gt;&gt; list(col.data)\n[1, 2, 3]\n&gt;&gt;&gt; col.data.total\n3\n</code></pre></p> <ol> <li>This has no sense, because data is already cached and <code>items</code> property will    not be used anymore</li> </ol> <p>To reset the cache and use <code>compute_data</code> again, call <code>refresh_data()</code> method of the data service.</p> <pre><code>&gt;&gt;&gt; col.data.items = \"hello\"\n&gt;&gt;&gt; col.data.refresh_data()\n&gt;&gt;&gt; list(col.data)\n[\"h\", \"e\", \"l\", \"l\", \"o\"]\n&gt;&gt;&gt; col.data.total\n5\n</code></pre> <p>Base <code>Data</code> class expects that <code>compute_data</code> returns a <code>collections.abc.Sequence</code>. With this expectation it implements <code>range(start, end)</code> that returns slice of the data, and <code>at(index)</code> that returns element with specified index.</p> <p>Example</p> <pre><code>class MyData(data.Data):\n    def compute_data(self):\n       return \"hello world\"\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; col.data.at(4)\n\"o\"\n&gt;&gt;&gt; col.data.range(6, None)\n\"world\"\n</code></pre> <p>These methods are also accessible via index operator.</p> <pre><code>&gt;&gt;&gt; col.data[4]\n\"o\"\n&gt;&gt;&gt; col.data[6:]\n\"world\"\n</code></pre> <p>If you are not going to rely on <code>compute_data</code> when extending <code>Data</code> class, implement your own caching logic and index-acces, if you need them.</p>"},{"location":"structure/data/#available-data-factories","title":"Available data factories","text":"<p>These factories are available at <code>ckanext.collection.shared.data</code>.</p>"},{"location":"structure/data/#collection.shared.data.Data","title":"<code>Data</code>","text":"<p>Base data source for collection.</p> <p>This class defines an outline of the data service. In basic case, sublcass should override <code>compute_data</code> method and return a Sequence from it to keep all methods functional.</p> Example <pre><code>class MyData(data.Data):\n    def compute_data(self):\n        return range(1, 20)\n</code></pre>"},{"location":"structure/data/#collection.shared.data.StaticData","title":"<code>StaticData</code>","text":"<p>Static data source.</p> <p>This class produce items from its <code>data</code> attribute. Use any sequence as a value for <code>data</code> during initialization.</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>sequence of items produced by the service</p> <p> TYPE: <code>Iterable[TData]</code> </p> Example <p><pre><code>NumericData = data.StaticData.with_attributes(data=range(1, 20))\n\nUppercaseData = data.StaticData.with_attributes(data=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=NumericData)\n&gt;&gt;&gt; list(col)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre></p>"},{"location":"structure/data/#collection.shared.data.CsvFileData","title":"<code>CsvFileData</code>","text":"<p>Data source for CSV file.</p> <p>CSV file available at path specified by <code>source</code> attribute of the service is read into memory and its every row transformed into dictionary.</p> ATTRIBUTE DESCRIPTION <code>source</code> <p>path to CSV source</p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.CsvFileData,\n&gt;&gt;&gt;     data_settings={\"source\": \"/path/to/file.csv\"},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[\n    {\"column_1\": \"value_1\", \"column_2\": \"value_2\"},\n    ...\n]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.ApiData","title":"<code>ApiData</code>","text":"<p>API data source.</p> <p>This base class is suitable for building API calls. Its <code>compute_data</code> makes the single request to the specified API action and yields items from the response.</p> ATTRIBUTE DESCRIPTION <code>action</code> <p>API action that returns the data</p> <p> TYPE: <code>str</code> </p> <code>payload</code> <p>parameters passed to the action</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>ignore_auth</code> <p>skip authorization checks</p> <p> TYPE: <code>bool</code> </p> <code>user</code> <p>name of the user for the action. Default: <code>tk.current_user.name</code></p> <p> TYPE: <code>str</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ApiData,\n&gt;&gt;&gt;     data_settings={\"action\": \"group_list_authz\", \"user\": \"default\"},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[{...}, {...}]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.ApiSearchData","title":"<code>ApiSearchData</code>","text":"<p>               Bases: <code>ApiData[TData, TDataCollection]</code></p> <p>API data source optimized for package_search-like actions.</p> <p>This class expects that API action accepts <code>start</code> and <code>rows</code> parameters that controls offset and limit. And result of the action must contain <code>count</code> and <code>results</code> keys.</p> <p>This data service can iterate over huge number of items, reading just few of them into the memory at once.</p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ApiSearchData,\n&gt;&gt;&gt;     data_settings={\n&gt;&gt;&gt;         \"action\": \"package_search\",\n&gt;&gt;&gt;         \"payload\": {\"q\": \"res_format:CSV\"},\n&gt;&gt;&gt;     },\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[{...}, {...}]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.BaseSaData","title":"<code>BaseSaData</code>","text":"<p>Abstract data source for SQL statements.</p> <p>This class can be extended to build data source over SQL statement.</p> ATTRIBUTE DESCRIPTION <code>use_naive_filters</code> <p>search by filterable columns from <code>params</code>. Default: true</p> <p> TYPE: <code>bool</code> </p> <code>use_naive_search</code> <p>if <code>params</code> contains <code>q</code>, ILIKE it against searchable columns. Default: true</p> <p> TYPE: <code>bool</code> </p> <code>session</code> <p>SQLAlchemy session</p> <p> TYPE: <code>AlchemySession</code> </p> Example <pre><code>import sqlalchemy as sa\nfrom ckan import model\n\nclass UserData(data.BaseSaData):\n    def get_base_statement(self):\n        return sa.select(model.User.name)\n</code></pre> <pre><code>&gt;&gt;&gt; col = collection.Collection(data_factory=data.UserData)\n&gt;&gt;&gt; list(col)\n[(\"default\",), (...,)]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.StatementSaData","title":"<code>StatementSaData</code>","text":"<p>               Bases: <code>BaseSaData[Select, TData, TDataCollection]</code></p> <p>Data source for arbitrary SQL statement.</p> ATTRIBUTE DESCRIPTION <code>statement</code> <p>select statement</p> <p> TYPE: <code>Select</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.StatementSaData,\n&gt;&gt;&gt;     data_settings={\"statement\": sa.select(model.User.name)},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"default\",), (...,)]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.UnionSaData","title":"<code>UnionSaData</code>","text":"<p>               Bases: <code>BaseSaData[Select, TData, TDataCollection]</code></p> <p>Data source for multiple SQL statement merged with UNION ALL.</p> ATTRIBUTE DESCRIPTION <code>statements</code> <p>select statements</p> <p> TYPE: <code>Select</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.UnionSaData,\n&gt;&gt;&gt;     data_settings={\"statements\": [\n&gt;&gt;&gt;         sa.select(model.User.name, sa.literal(\"user\")),\n&gt;&gt;&gt;         sa.select(model.Package.name, sa.literal(\"package\")),\n&gt;&gt;&gt;         sa.select(model.Group.name, sa.literal(\"group\")),\n&gt;&gt;&gt;     ]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[(\"default\", \"user\"),\n(\"warandpeace\", \"package\"),\n(\"my-cool-group\", \"group\")]\n</code></pre>"},{"location":"structure/data/#collection.shared.data.ModelData","title":"<code>ModelData</code>","text":"<p>               Bases: <code>BaseSaData[Select, TData, TDataCollection]</code></p> <p>Data source for SQLAlchemy model.</p> ATTRIBUTE DESCRIPTION <code>model</code> <p>main model used by data source</p> <p> TYPE: <code>Any</code> </p> <code>is_scalar</code> <p>return model instance instead of collection of columns.</p> <p> TYPE: <code>bool</code> </p> Example <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.ModelData,\n&gt;&gt;&gt;     data_settings={\"model\": model.User, \"is_scalar\": True},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; list(col)\n[&lt;User ...&gt;, ...]\n</code></pre>"},{"location":"structure/domain/","title":"Abstract service","text":"<p>It's a concept, not a real service. This concept is used as a base by absolutely every service of any collection. And if you decide to introduce a brand new service, it will extend the base abstract service.</p> <p>Because this abstract service is used by every service type, it defines a number of standard traits of every service. Everything you'll learn in this chapter can be applied to every service you see in a real application.</p>"},{"location":"structure/domain/#service","title":"Service","text":"<p>The abstract service actually consists of two classes. The first one is <code>types.Service</code>. This is an abrstract class, which contains abstract property <code>service_name</code>. The property identifies the name of the service inside the collection.</p> <p>The base <code>data.Data</code> class implements <code>types.Service</code> and its implementation of <code>service_name</code> returns <code>data</code>. The base <code>serialize.Serializer</code> has <code>service_name</code> that returns <code>serializer</code>. And every other type of service does similar thing.</p> <p>Because of this, collection knows, where to put the service in the following code snippet:</p> <pre><code>src = collection.Collection(data_factory=data.StaticData)\ndest = collection.Collection()\ndest.replace_service(src.data)\n</code></pre> <p>We don't tell collection, that we are replacing the data service. But because the object passed into <code>replace_service</code> has <code>service_name</code> property, collection can recognize it and assign into correct attribute.</p> <p>If someone create a service that provides Solr connection, this service will get <code>service_name</code> property with value <code>solr</code>. And because of it, collection will keep any instance of such service as <code>col.solr</code>.</p>"},{"location":"structure/domain/#domain","title":"Domain","text":"<p>The second component of abstract service is <code>Domain</code>. <code>Domain</code> and <code>types.Service</code> are always used together. Every non-abstract service is subclassed from both <code>Domain</code> and <code>types.Service</code>.</p> <p><code>Domain</code> provides a set of convenient features for services.</p> <p>First, and probably most important, it defines the constructor of service as method with one positional-only argument(the collection) and any number of keyword-only arguments(settings). Thanks to <code>Domain</code>, when service is initialized, it's automatically attached to collection.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; data.StaticData(col)\n&gt;&gt;&gt; isinstance(col.data, data.StaticData)\nTrue\n</code></pre> <p>Settings are processed in a special way and will be described further inside settings section.</p> <p><code>Domain</code> exposes collection as <code>attached</code> property of the service. This is the two-way reference: collection contains link to its services and every service contains a link to the collection.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection()\n&gt;&gt;&gt; col.data.attached is col\nTrue\n&gt;&gt;&gt; col.columns.attached is col\nTrue\n&gt;&gt;&gt; col.pager.attached is col\nTrue\n</code></pre> <p>And <code>Domain</code> provides <code>with_attributes</code> classmethod inside service. This method creates a subclass of the caller with overridden attributes.</p> <pre><code>&gt;&gt;&gt; MyData = data.Data.with_attributes(a=1, b=2)\n&gt;&gt;&gt; col = collection.Collection(data_factory=MyData)\n&gt;&gt;&gt; col.data.a\n1\n&gt;&gt;&gt; col`.data.b\n2\n</code></pre>"},{"location":"structure/domain/#settings","title":"Settings","text":"<p>Service settings are passed as keyword-only arguments to service constructor or as <code>&lt;SERVICE&gt;_settings</code> dictionary to collection constructor. In both cases settings are processed in the same way. Service keeps known parameters and ignores everything else.</p> <p>That's a rule. Service does not keeps all the settings, it stores only settings that are registered inside the service.</p> <p>Example</p> <p>As <code>Data</code> has no settings, the whole <code>data_settings</code> is ignored.</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=data.Data,\n&gt;&gt;&gt;     data_settings={\"a\": 1, \"b\": 2, \"data\": [1, 2, 3]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; hasattr(col.data, \"a\")\nFalse\n&gt;&gt;&gt; hasattr(col.data, \"b\")\nFalse\n&gt;&gt;&gt; hasattr(col.data, \"c\")\nFalse\n</code></pre> <p>Every configurable attribute of the service must be registered first, and only then you can set it via settings.</p> <p>To register the attribute, you have to create it inside class definition. And its value must be generated by <code>configurable_attribute</code> function.</p> <p>Example</p> <pre><code>from ckanext.collection.shared import collection, data, configurable_attribute\n\nclass MyData(data.Data):\n    a = configurable_attribute(\"default a\") # (1)!\n    b = configurable_attribute(default_factory=lambda self: \"default b\") # (2)!\n    c = configurable_attribute() # (3)!\n</code></pre> <ol> <li>Positional argument is used as default value for the attribute</li> <li>Named <code>default_factory</code> accepts a function that receives the service    instance and returns default value of attribute.</li> <li>If no default provided, attribute becomes mandatory and will cause an    exception if missing during initialization of service.</li> </ol> <p><code>configurable_attribute</code> accepts either static default value or a function that produces default value. Such function must be passed via named argument <code>default_factory</code> and must accept the only parameter: the service itself. If <code>configurable_attribute</code> is called without arguments, it registers a required attribute and service cannot be initialized without this attribute.</p> <p>Warning</p> <p>It's not allowed to use other configurable attributes inside <code>default_factory</code> of configurable attribute. The initialization order of configurable attributes is not defined at the moment. There are not guarantees that referred attribute is already initialized when <code>default_factory</code> is called.</p> <p>Any configurable attribute can be assigned via settings. If you try using settings with the class from the example above, registered attributes will be picked and added to the service:</p> <pre><code>&gt;&gt;&gt; col = collection.Collection(\n&gt;&gt;&gt;     data_factory=MyData,\n&gt;&gt;&gt;     data_settings={\"a\": 1, \"b\": 2, \"c\": [1, 2, 3]},\n&gt;&gt;&gt; )\n&gt;&gt;&gt; col.data.a\n1\n&gt;&gt;&gt; col.data.b\n2\n&gt;&gt;&gt; col.data.c\n[1, 2, 3]\n</code></pre> <p>Tip</p> <p><code>with_attributes</code> also can create configurable attributes.</p> <pre><code>from ckanext.collection.shared import data, configurable_attribute\n\nMyData = data.Data.with_attributes(\n    a=configurable_attribute(\"default a\"),\n    b=configurable_attribute(default_factory=lambda self: \"default b\"),\n    c=configurable_attribute(),\n)\n</code></pre>"},{"location":"structure/filters/","title":"Filters","text":"<p>This service used only by HTML table serializers at the moment. It has two configurable attributes <code>static_filters</code> and <code>static_actions</code>. <code>static_filters</code> are used for building search form for the data table. <code>static_actions</code> are not used, but you can put into it details about batch or record-level actions and use these details to extend one of standard serializers. For example, ckanext-admin-panel defines allowed actions (remove, restore, hide) for content and creates custom templates that are referring these actions.</p>"},{"location":"structure/pager/","title":"Pager","text":"<p>Pager service sets the upper and lower bounds on data used by collection. Default pager used by collection relies on numeric <code>start</code>/<code>end</code> values. But it's possible to define custom pager that uses alphabetical or temporal bounds, as long as <code>range</code> method of your custom data service supports these bounds.</p> <p>Standard pager(<code>ClassicPager</code>) has two configurable attributes: <code>page</code>(default: 1) and <code>rows_per_page</code>(default: 10).</p> <pre><code>col = StaticCollection(\"name\", {})\nassert col.pager.page == 1\nassert col.pager.rows_per_page == 10\n</code></pre> <p>Because of these values you see only first 10 records from data when iterating the collection. Let's change pager settings:</p> <pre><code>col = StaticCollection(\n    \"name\", {},\n    data_settings={\"data\": range(1, 100)},\n    pager_settings={\"page\": 3, \"rows_per_page\": 6}\n)\nassert list(col) == [13, 14, 15, 16, 17, 18]\n</code></pre> <p>Pagination details are often passed with search parameters and have huge implact on the required data frame. Because of it, if <code>pager_settings</code> are missing, <code>ClassicPager</code> will look for settings inside collection parameters(second argument of the collection constructor). But in this case, pager will use only items that has <code>&lt;collection name&gt;:</code> prefix:</p> <pre><code>col = StaticCollection(\n    \"xxx\",\n    {\"xxx:page\": 3, \"xxx:rows_per_page\": 6},\n    data_settings={\"data\": range(1, 100)}\n)\nassert list(col) == [13, 14, 15, 16, 17, 18]\n\ncol = StaticCollection(\n    \"xxx\",\n    {\"page\": 3, \"rows_per_page\": 6},\n    data_settings={\"data\": range(1, 100)}\n)\nassert list(col) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n</code></pre>"},{"location":"structure/serializer/","title":"Serializer","text":"<p>Serializer converts data into textual, binary or any other alternative representation. For example, if you want to compute records produced by the <code>data</code> service of the collection into pandas' DataFrame, you should probably use serializer.</p> <p>Serializers are main users of columns service, because it contains details about specific data columns. And serializers often iterate data service directly(ignoring <code>range</code> method), to serialize all available records.</p> <p>The only required method for serializer is <code>serialize</code>. This method must return an data from <code>data</code> service transformed into format provided by serializer. For example, <code>JsonSerializer</code> returns string with JSON-encoded data.</p> <p>You are not restricted by textual or binary formats. Serializer that transforms data into pandas' DataFrame is completely valid version of the serializer.</p> <pre><code>class NewLineSerializer(Serializer):\n    def serialize(self):\n        result = \"\"\n        for item in self.attached.data:\n            result += str(item) + \"\\n\"\n\n        return result\n\ncol = StaticCollection(\n    \"name\", {},\n    serializer_factory=NewLineSerializer,\n    data_settings={\"data\": [1, 2, 3]}\n)\nassert \"\".join(col.serializer.serialize()) == \"1\\n2\\n3\\n\"\n</code></pre>"}]}